..

脱壳篇
======

认识壳是什么
------------

``壳`` 是在一些计算机软件里也有一段专门负责保护软件不被非法修改或反编译的程序。

它们一般都是先于程序运行，拿到控制权，然后完成它们保护软件的任务。

.. figure:: /reverse/images/what-is-pack.png
   :alt: 什么是壳

由于这段程序和自然界的壳在功能上有很多相同的地方，基于命名的规则，就把这样的程序称为 ``壳`` 了。

壳的分类
--------

我们通常将 ``壳`` 分为两类，一类是 ``压缩壳`` ，另一类是 ``加密壳`` 。

压缩壳
~~~~~~

``压缩壳`` 早在 DOS
时代就已经出现了，但是当时因为计算能力有限，解压开销过大，并没有得到广泛的运用。

使用压缩壳可以帮助缩减 PE 文件的大小，隐藏了 PE
文件内部代码和资源，便于网络传输和保存。

通常压缩壳有两类用途，一种只是单纯用于压缩普通 PE
文件的压缩壳，而另一种则会对源文件进行较大变形，严重破坏 PE
文件头，经常用于压缩恶意程序。

常见的压缩壳有： ``Upx`` ``ASpack`` ``PECompat``

加密壳
~~~~~~

``加密壳`` 或称保护壳，应用有多种防止代码逆向分析的技术，它最主要的功能是 ``保护PE免受代码逆向分析`` 。

由于加密壳的主要目的不再是压缩文件资源，所以加密壳保护的 PE
程序通常比原文件大得多。

目前加密壳大量用于对安全性要求高，对破解敏感的应用程序，同时也有恶意程序用于避免(降低)杀毒软件的检测查杀。

常见的加密壳有： ``ASProtector`` ``Armadillo`` ``EXECryptor``
``Themida`` ``VMProtect``

壳的加载过程
------------

保存入口参数
~~~~~~~~~~~~

1. 加壳程序初始化时保存各寄存器的值
2. 外壳执行完毕，恢复各寄存器值
3. 最后再跳到原程序执行

通常用pushad/popad、pushfd/popfd指令对来保存和恢复现场环境

获取所需函数 API
~~~~~~~~~~~~~~~~

1. 一般壳的输入表中只有GetProcAddress、GetModuleHandle和LoadLibrary这几个API函数

2. 如果需要其他 API 函数，则通过 LoadLibraryA(W) 或 LoadLibraryExA(W)
   将DLL文件映射到调用进程的地址空间中

3. 如果DLL文件已被映射到调用进程的地址空间里，就可以调用
   GetModuleHandleA(W)函数获得DLL模块句柄

4. 一旦DLL模块被加载，就可以调用 GetProcAddress函数获取输入函数的地址

解密各区块数据
~~~~~~~~~~~~~~

1. 处于保护源程序代码和数据的目的，一般会加密源程序文件的各个区块。在程序执行时外壳将这些区块数据解密，以让程序正常运行。

2. 外壳一般按区块加密，按区块解密，并将解密的数据放回在合适的内存位置。

跳转回原程序入口点
~~~~~~~~~~~~~~~~~~

1. 在跳转回入口点之前，一般会恢复填写原PE文件输入表(IAT)，并处理好重定位项(主要是dll文件)

2. 因为加壳时外壳自己构造了一个输入表，因此在这里需要重新对每一个DLL引入的所有函数重新获取地址，并填写到IAT表中

3. 做完上述工作后，会将控制权移交原程序，并继续执行。

讲讲如何手动加壳
----------------

脱壳的６种方法
--------------

本节介绍脱壳中常用的6种方法： ``单步跟踪法`` ，  ``ESP定律法`` ， ``一步到达OEP法`` ， ``内存镜像法`` ，  ``最后一次异常法`` ， ``SFX法``  。

0x01 单步跟踪法
~~~~~~~~~~~~~~~

单步跟踪法的原理就是通过Ollydbg的单步（F8）、单步进入（F7）和运行到（F4）功能，完整走过程序的自脱壳过程，跳过一些循环恢复代码的片段，并用单步进入确保程序不会略过OEP。这样可以在软件自动脱壳模块运行完毕后，到达OEP，并dump程序。

-  打开程序按F8单步向下，尽量实现向下的jmp跳转
-  会经常遇到大的循环，这时要多用 F4 来跳过循环
-  如果函数载入时不远处就是一个call（近call），那么我们尽量不要直接跳过，而是进入这个call
-  一般跳转幅度大的jmp指令，都极有可能是跳转到了原程序入口点（OEP）

示例程序：1-单步跟踪法

0x02 ESP定律法
~~~~~~~~~~~~~~

ESP定律法是脱壳的利器，是应用频率最高的脱壳方法之一。

ESP定律的原理在于程序中堆栈平衡的合理利用。

由于在程序自解密或者自解压过程中，不少壳会先将当前寄存器内容压栈，如使用pushad，在解压结束后，会将之前的寄存器值出栈，如使用popad。
因此在寄存器出栈时，往往程序代码被自动恢复，此时硬件断点触发。然后在程序当前位置，只需要少许单步跟踪，就很容易到达正确的OEP位置。

-  程序刚载入开始pushad/pushfd
-  将全部寄存器压栈后就设对ESP寄存器设硬件断点

示例程序：2-ESP定律法

0x03 一步到达OEP法
~~~~~~~~~~~~~~~~~~

所谓的一步到达OEP的脱壳方法，是根据所脱壳的特征，寻找其距离OEP最近的一处汇编指令，然后下int3断点，在程序走到OEP的时候dump程序。
如一些压缩壳往往popad指令距离OEP或者大Jmp特别近，因此使用Ollydbg的搜索功能，可以搜索壳的特征汇编代码，达到一步断点到达OEP的效果。

-  Ctrl+F查找popad
-  只适用于极少数压缩壳

示例程序：3-一步到达OEP法

0x04 内存镜像法
~~~~~~~~~~~~~~~

内存镜像法是在加壳程序被加载时，通过OD的ALT+M快捷键，进入到程序虚拟内存区段。然后通过加两次内存一次性断点，到达程序正确OEP的位置。

内存镜像法的原理在于对于程序资源段和代码段下断点，一般程序自解压或者自解密时，会首先访问资源段获取所需资源，然后在自动脱壳完成后，转回程序代码段。这时候下内存一次性断点，程序就会停在OEP处。

-  选项——调试选项——异常
-  勾选所有忽略异常
-  ALT+M,打开内存镜象，找到程序的第一个.rsrc.按F2下断点，然后按SHIFT+F9运行到断点
-  再按ALT+M,打开内存镜象，找到程序的第一个.rsrc.上面的.text（也就是00401000处），按F2下断点！然后按SHIFT+F9（或者是在没异常情况下按F9）

示例程序：4-内存镜像法

0x05 最后一次异常法
~~~~~~~~~~~~~~~~~~~

最后一次异常法的原理是，程序在自解压或自解密过程中，可能会触发无数次的异常。如果能定位到最后一次程序异常的位置，可能就会很接近自动脱壳完成位置。现在最后一次异常法脱壳可以利用Ollydbg的异常计数器插件，先记录异常数目，然后重新载入，自动停在最后一次异常处。

-  点击选项——调试选项——异常，把里面的√全部去掉！CTRL+F2重载下程序
-  开始程序就是一个跳转，在这里我们按SHIFT+F9，直到程序运行，记下从开始按SHIFT+F9到程序运行的次数m！

-  CTRL+F2重载程序，按SHIFT+F9（这次按的次数为程序运行的次数m-1次）
-  在OD的右下角我们看见有一个"SE 句柄"，这时我们按CTRL+G，输入SE
   句柄前的地址！
-  按F2下断点！然后按SHIFT+F9来到断点处, F8单步跟踪

示例程序：5-最后一次异常法

0x06 "SFX"法
~~~~~~~~~~~~

"SFX"法利用了Ollydbg自带的OEP寻找功能，可以选择直接让程序停在OD找到的OEP处，此时自解压已经完成，可以直接dump程序。

-  设置OD，忽略所有异常，也就是说异常选项卡里面都打上勾
-  切换到SFX选项卡，选择“字节模式跟踪实际入口（速度非常慢）”，确定。
-  重载程序（如果跳出是否“压缩代码？”选择“否”，OD直接到达OEP）

示例程序：6-SFX法

脱壳工作流
----------

加密壳脱壳示例
--------------
