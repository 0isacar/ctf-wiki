# ELF文件

> 本部分内容来源于ELF 1.2 标准，内容经过一定的修改与整理。

# 简介

ELF文件，也就是在Linux中的目标文件，主要有以下三种类型

- 可重定位文件（Relocatable File），包含由编译器生成的代码以及数据。它被链接器linker用来与其它目标文件链接从而创建可执行文件或者共享目标文件。在Linux系统中，一般以 `.o` 文件形式存在。
- 可执行文件（Executable File），就是我们通常在Linux执行的程序。


- 共享目标文件（Shared Object File），包含代码和数据，这种文件一般就是我们所称的库文件，一般以 `.so` 结尾。一般情况下，它一般有以下两种使用情景
  - 链接器（Link eDitor, ld）可能会一起处理它和其它可重定位文件以及共享目标文件，生成另外一个目标文件。
  - 动态链接器（Dynamic Linker）将它与可执行文件以及其它共享目标一起组合，创建进程映像。

> 关于Link eDitor的命名，https://en.wikipedia.org/wiki/GNU_linker

目标文件由汇编器和链接器创建，是文本程序的二进制形式，其目的是希望可以直接在处理器上运行。那些需要虚拟机才能够执行的程序(Java)不属于这一范围。

这里我们主要关注于文件格式以及它和生成程序的关系。

## 文件格式

目标文件既会参与程序链接又会参与程序执行。出于方便性和效率考虑，目标文件格式根据过程的不同提供了其内容的两种并行视图，如下

![](/executable/ELF/figure/object_file_format.png)

文件开始处是 ELF 头部（ **ELF  Header**），它给出了整个文件的组织情况。节区部分包含在链接视图中要使用的大部分信息：指令、数据、符号表、重定位信息等等。关于其他的部分，我们后面再叙述。这里我们主要关注于链接视图。

如果程序头部表（Program Header Table）存在的话，它告诉系统如何创建进程映像。用来生成进程映像的目标文件必须具有程序头部表，但是重定位文件不需要这个表。

节区头部表（Section Heade Table）包含了描述文件节区的信息，每个节区在表中都有一个表项，每一项会给出节区名称、节区大小等信息。用于链接的目标文件必须有节区头部表，其它目标文件则无所谓，可以有，也可以没有。

注意:

> 尽管图中是按照ELF头，程序头部表，节区，节区头部表的顺序排列的。但实际上除了 ELF  头部表以外，其它部分都没有严格的的顺序。

## 数据形式

目标文件格式支持 8 位/32 位体系结构。当然，这种格式是可以扩展的，也可以支持小的或者大的位数的处理器架构。因此，目标文件会包含一些控制数据，这部分数据表明了目标文件所使用的架构，这也使得它可以被一种通用的方式来识别和解释。目标文件中的其它数据采用目的处理器的编码，与在何种机器上创建没有关系。这里其实也就是可以进行交叉编译，我们可以在X86平台生成arm平台的可执行代码。

目标文件中的所有数据结构都遵从“自然”大小和对齐规则。如下

| 名称            |  长度  | 对齐方式 |   用途    |
| :------------ | :--: | :--: | :-----: |
| Elf32_Addr    |  4   |  4   | 无符号程序地址 |
| Elf32_Half    |  2   |  2   | 无符号半整型  |
| Elf32_Off     |  4   |  4   | 无符号文件偏移 |
| Elf32_Sword   |  4   |  4   | 有符号大整型  |
| Elf32_Word    |  4   |  4   | 无符号大整型  |
| unsigned char |  1   |  1   | 无符号小整型  |

如果必要，数据结构可以包含显式的补齐来确保 4 字节对象按 4 字节边界对齐，强制数据结构的大小是4的整数倍等等。数据同样适用是对齐的。因此，包含一个Elf32_Addr类型成员的结构体会在文件中4字节边界处对齐。

为了具有可移植性，ELF文件不适用位域。

## 字符表示

待。

# ELF Header

## 基本信息

有些目标文件控制结构的大小可以变化，因为ELF头有它们的实际大小。如果目标文件格式改变，程序可能会遇到比预期大或者小的控制结构。程序可能因此忽略“额外”信息。至于如何处理“丢失”信息，它取决于相应的环境，有时候也会在定义扩展时被明确地指定如何处理。

ELF Header部分的数据结构如下：

```c
#define EI_NIDENT	16

typedef struct {
	unsigned char	e_ident[EI_NIDENT];
	ELF32_Half		e_type;
	ELF32_Half		e_machine;
	ELF32_Word		e_version;
	ELF32_Addr		e_entry;
	ELF32_Off		e_phoff;
	ELF32_Off		e_shoff;
	ELF32_Word		e_flags;
	ELF32_Half		e_ehsize;
	ELF32_Half		e_phentsize;
	ELF32_Half		e_phnum;
	ELF32_Half		e_shentsize;
	ELF32_Half		e_shnum;
	ELF32_Half		e_shstrndx;
} Elf32_Ehdr;
```

其中每个成员都是e开头的，它们应该都是ELF的缩写。

## 详细内容

### e_ident

正如之前所说，ELF提供了一个目标文件框架来支持多种处理器，多种编码格式以及多种类型的机器。这部分字节就提供了用于解码和解释文件中与机器无关的数据的方式。这个数组对于不同的下标的含义如下

| 名称         | 取值   | 目的      |
| ---------- | ---- | ------- |
| EI_MAG0    | 0    | 文件标识    |
| EI_MAG1    | 1    | 文件标识    |
| EI_MAG2    | 2    | 文件标识    |
| EI_MAG3    | 3    | 文件标识    |
| EI_CLASS   | 4    | 文件类     |
| EI_DATA    | 5    | 数据编码    |
| EI_VERSION | 6    | 文件版本    |
| EI_PAD     | 7    | 补齐字节开始处 |

其中，

`e_ident[EI_MAG0]`  到 `e_ident[EI_MAG3]`，即文件的头4个字节，被称作“魔数”，标识该文件是一个ELF目标文件。至于开头为什么是0x7f，并没有仔细去查过。

| 名称      | 值    | 位置               |
| ------- | ---- | ---------------- |
| ELFMAG0 | 0x7f | e_ident[EI_MAG0] |
| ELFMAG1 | ‘E’  | e_ident[EI_MAG1] |
| ELFMAG2 | ‘L’  | e_ident[EI_MAG2] |
| ELFMAG3 | ‘F’  | e_ident[EI_MAG3] |

`e_ident[EI_CLASS]` 为 `e_ident[EI_MAG3]`的下一个字节，标识文件的类型或容量。

| 名称           | 值    | 意义    |
| ------------ | ---- | ----- |
| ELFCLASSNONE | 0    | 无效类型  |
| ELFCLASS32   | 1    | 32位文件 |
| ELFCLASS64   | 2    | 64位文件 |

ELF 文件被设计成能够在多种字节长度的机器之间移植，而不需要强制规定机器的最长字节长度和最短字节长度。`ELFCLASS32`类型支持文件大小和虚拟地址空间上限为4GB的机器；它使用上述定义中的基本类型。

`ELFCLASS64`类型被保留用于64位架构。它在这里的出现表明目标文件可能会改变。在必要时，会定义附带有不同的基本类型和目标文件数据大小的其它类型，可能是128位？

`e_ident[EI_DATA]`字节给出了目标文件中的特定处理器数据的编码方式。下面是目前已定义的编码：

| 名称          | 值    | 意义     |
| ----------- | ---- | ------ |
| ELFDATANONE | 0    | 无效数据编码 |
| ELFDATA2LSB | 1    | 参考下文   |
| ELFDATA2MSB | 2    | 参考下文   |

其它值被保留，在未来必要时将被赋予新的编码。

文件数据编码方式表明了对于文件中内容的解析方式。正如之前所述，`ELFCLASS32`类型文件使用了具有1，2和4字节的变量类型。对于已定义的不同的编码方式，其表示如下所示，其中字节号在左上角。

`ELFDATA2LSB`编码使用补码，最低有效位（Least Significant Byte）占用最低地址。

![](/executable/ELF/figure/elfdata2lsb.png)

`ELFDATA2MSB`编码使用补码，最高有效位（Most Significant Byte）占用最低地址。

![](/executable/ELF/figure/elfdata2msb.png)

`e_ident[EI_DATA]`给出了ELF头的版本号。目前来说，这个值必须是`EV_CURRENT`，即之前已经给出的`e_version`项。

`e_ident[EI_PAD]` 给出了 `e_ident` 中未使用字节的开始地址。这些字节被保留并置为0；处理目标文件的程序应该忽略它们。如果之后这些字节被使用，EI_PAD的值就会改变。

### e_type

`e_type`标识目标文件类型。

| 名称        | 值      | 意义     |
| --------- | ------ | ------ |
| ET_NONE   | 0      | 无文件类型  |
| ET_REL    | 1      | 可重定位文件 |
| ET_EXEC   | 2      | 可执行文件  |
| ET_DYN    | 3      | 共享目标文件 |
| ET_CORE   | 4      | 核心转储文件 |
| ET_LOPROC | 0xff00 | 处理器指定  |
| ET_HIPROC | 0xffff | 处理器指定  |

虽然核心转储文件的内容没有被详细说明，但 `ET_CORE` 还是被保留用于标志此类文件。从`ET_LOPROC`到`ET_HIPROC`(包括边界)值被保留用于处理器指定的场景。其他值在未来必要时可被赋予新的目标文件类型。

### e_machine

这一项指定了当前文件需要的机器架构。

| 名称       | 值    | 意义             |
| -------- | ---- | -------------- |
| EM_NONE  | 0    | 无机器类型          |
| EM_M32   | 1    | AT&T WE 32100  |
| EM_SPARC | 2    | SPARC          |
| EM_386   | 3    | Intel 80386    |
| EM_68K   | 4    | Motorola 68000 |
| EM_88K   | 5    | Motorola 88000 |
| EM_860   | 7    | Intel 80860    |
| EM_MIPS  | 8    | MIPS RS3000    |

其中EM应该是ELF Machine的简写。

其它值被在未来必要时用于赋予新的机器。 特定处理器的ELF名称使用机器名称来进行区分。例如，下面的标志（flag）使用前缀`EF_` （ELF Flag）；在`EM_XYZ`机器上名叫 `WIDGET` 的标志将被称为 `EF_XYZ_WIDGET`。

### e_version

标识目标文件的版本。

| 名称         | 值    | 意义   |
| ---------- | ---- | ---- |
| EV_NONE    | 0    | 无效版本 |
| EV_CURRENT | 1    | 当前版本 |

1表示初始文件格式；未来扩展新的版本的时候(extensions)将使用更大的数字。虽然在上面值`EV_CURRENT`为1，但是为了反映当前版本号，它可能会改变，**比如ELF到现在也就是1.2版本。**

### e_entry

这一项给出系统转交控制权给ELF中的代码时的虚拟地址。如果没有相关的入口项，则这一项为0。

### e_phoff

这一项给出程序头部表在文件中的字节偏移（**Program Header table OFFset**）。如果文件中没有程序头部表，则该项为0。

### e_shoff

这一项给出节头表在文件中的字节偏移（ **Section Header table OFFset** ）。如果文件中没有节头表，则本项值为0。

### e_flags

这一项给出文件中与特定处理器相关的标志，这些标志命名方式为`EF_machine_flag`。

### e_ehsize

这一项给出ELF文件头部的字节长度（ELF Header Size）。

### e_phentsize

这一项给出程序头部表中每个入口的字节长度（**Program Header ENTry SIZE**），其中，每个入口的大小相同。

### e_phnum

这一项给出程序头部表中的入口的项数（ **Program Header entry NUMber** ）。因此，`e_phnum` 与 `e_phentsize` 的乘积即为程序头部表的字节长度。如果文件中没有程序头部表，则该项值为0。

### e_shentsize

这一项给出节头的字节长度（**Section Header ENTry SIZE**）。一个节头是节头表中的一项；节头表中所有项占据的空间大小相同。

### e_shnum

这一项给出节头表中的项数（**Section Header NUMber**）。因此， `e_shnum` 与 `e_shentsize` 的乘积即为节头表的字节长度。如果文件中没有节头表，则该项值为0。

### e_shstrndx

这一项给出节头表中与节名字符串表相关的表项的索引值（**Section Header table InDeX related with section  name STRing table**）。如果文件中没有节名字符串表，则该项值为`SHN_UNDEF`。更多更加细节的介绍，请参考后面的“节”和“字符串表”部分。

# Sections

节区包含目标文件中除了ELF 头部、程序头部表、节区头部表的所有信息。节区满足以下条件

- 目标文件中的每个节区都有对应的节头来描述它。但是反过来，有节区头部不意味着有节区。
- 每个节区占用文件中的连续字节区域（这个区域的长度可能为 0）。
- 文件中的节区不能重叠，一个字节不能同时存在于两个节区中。
- 目标文件中可能会有闲置空间（inactive space），各种头和节不一定会覆盖到目标文件中的所有字节，闲置区域的内容未指定。

## 节头表

目标文件的节头表可以帮助定位文件中的所有节。节头表是一个 `ELF32_Shdr` 类型的数组，节头表索引是数组中元素的下标。ELF头中的 `e_shoff` 项给出了从文件开头到节头表位置的字节偏移；`e_shnum` 告诉了我们节头表包含的项数；`e_shentsize` 给出了每一项的字节大小。

节头表中比较特殊的几个下标如下

| 名称            | 值      | 含义                                       |
| ------------- | ------ | ---------------------------------------- |
| SHN_UNDEF     | 0      | 标志未定义的，丢失的，不相关的或者其它没有意义的节引用。例如，与节号SHN_UNDEF相关的“定义"的符号就是一个未定义符号。**注：虽然0号索引被保留用于未定义值，节头表仍然包含索引0的项。也就是说，如果ELF头的e_shnum为6，那么索引应该为0~5。更加详细的内容在后面会说明。** |
| SHN_LORESERVE | 0xff00 | 保留索引值范围的下界。                              |
| SHN_LOPROC    | 0xff00 | 处理器相关的下界                                 |
| SHN_HIPROC    | 0xff1f | 处理器相关的上界                                 |
| SHN_ABS       | 0xfff1 | 相关引用的绝对值。例如与节号SHN_ABS相关的符号拥有绝对值，它们不受重定位的影响 |
| SHN_COMMON    | 0xfff2 | 这一节区相定义的符号是通用符号，例如FORTRAN COMMON，C语言中未分配的外部变量。 |
| SHN_HIRESERVE | 0xffff | 保留索引值范围的上界。                              |

**系统保留在`SHN_LORESERVE`到`SHN_HIRESERVE`之间(包含边界)的索引值，这些值不在节头表中引用。也就是说，节头表不包含保留索引项。没特别理解。**

## 节区头部

每个节区头部可以用下面的数据结构进行描述：

```c
typedef struct {
	ELF32_Word		sh_name;
	ELF32_Word		sh_type;
	ELF32_Word		sh_flags;
	ELF32_Addr		sh_addr;
	ELF32_Off		sh_offset;
	ELF32_Word		sh_size;
	ELF32_Word		sh_link;
	ELF32_Word		sh_info;
	ELF32_Word		sh_addralign;
	ELF32_Word		sh_entsize;
} Elf32_Shdr;
```

每个字段的含义如下。

| 成员           | 说明                                       |
| :----------- | ---------------------------------------- |
| sh_name      | 节名称，是节区头部字符串表节区（Section Header String Table Section）的索引，其内容是以NULL结尾的字符串。 |
| sh_type      | 根据节的内容和语义进行分类，具体的类型下面介绍。                 |
| sh_flags     | 每一比特代表不同的标志，从来描述多种属性。                    |
| sh_addr      | 如果节区将出现在进程的内存映像中，此成员给出节区的第一个字节应该在进程镜像中的位置。否则，此字段为 0。 |
| sh_offset    | 给出节区的第一个字节与文件开始处之间的偏移。SHT_NOBITS 类型的节区不占用文件的空间，因此其 sh_offset 成员给出的是概念性的偏移。 |
| sh_size      | 此成员给出节区的字节大小。除非节区的类型是 SHT_NOBITS ，否则该节占用文件中的 sh_size  字节。类型为SHT_NOBITS 的节区长度可能非零，不过却不占用文件中的空间。 |
| sh_link      | 此成员给出节区头部表索引链接，其具体的解释依赖于节区类型。            |
| sh_info      | 此成员给出附加信息，其解释依赖于节区类型。                    |
| sh_addralign | 某些节区的地址需要对齐。例如，如果一个节区有一个doubleword类型的变量，那么系统必须保证整个节区按双字对齐。也就是说，$sh\_addr \% sh\_addralign$=0。目前它仅允许为0，以及2的正整数幂数。 0 和 1 表示没有对齐约束。 |
| sh_entsize   | 某些节区中存在具有固定大小的表项的表，如符号表。对于这类节区，该成员给出每个表项的字节大小。反之，此成员取值为0。 |

 正如之前所说，索引为零（SHN_UNDEF）的节区头也存在，尽管此索引标记的是未定义的节区引用。这一项的信息如下

| 字段名称         | 取值        | 说明    |
| ------------ | --------- | ----- |
| sh_name      | 0         | 无名称   |
| sh_type      | SHT_NULL  | 限制    |
| sh_flags     | 0         | 无标志   |
| sh_addr      | 0         | 无地址   |
| sh_offset    | 0         | 无文件偏移 |
| sh_size      | 0         | 无大小   |
| sh_link      | SHN_UNDEF | 无链接信息 |
| sh_info      | 0         | 无辅助信息 |
| sh_addralign | 0         | 无对齐要求 |
| sh_entsize   | 0         | 无表项   |

## 部分节头字段

### sh_type

节类型目前有下列可选范围，其中SHT是**Section Header Table** 的简写。

| 名称           | 取值         | 说明                                       |
| ------------ | ---------- | ---------------------------------------- |
| SHT_NULL     | 0          | 该类型节区是非活动的，这种类型的节头中的其它成员取值无意义。           |
| SHT_PROGBITS | 1          | 该类型节区包含程序定义的信息，它的格式和含义都由程序来决定。           |
| SHT_SYMTAB   | 2          | 该类型节区包含一个符号表（**SYMbol TABle**）。目前目标文件对每种类型的节区都只  能包含一个，不过这个限制将来可能发生变化。  一般，SHT_SYMTAB 节区提供用于链接编辑（指 ld  而言） 的符号，尽管也可用来实现动态链接。 |
| SHT_STRTAB   | 3          | 该类型节区包含字符串表（ **STRing TABle** ）。         |
| SHT_RELA     | 4          | 该类型节区包含显式指定位数的重定位项（ **RELocation entry with Addends** ），例如，32 位目标文件中的 Elf32_Rela 类型。此外，目标文件可能拥有多个重定位节区。 |
| SHT_HASH     | 5          | 该类型节区包含符号哈希表（ **HASH table** ）。          |
| SHT_DYNAMIC  | 6          | 该类型节区包含动态链接的信息（ **DYNAMIC linking** ）。   |
| SHT_NOTE     | 7          | 该类型节区包含以某种方式标记文件的信息（**NOTE**）。           |
| SHT_NOBITS   | 8          | 该类型节区不占用文件的空间，其它方面和SHT_PROGBITS相似。尽管该类型节区不包含任何字节，其对应的节头成员sh_offset 中还是会包含概念性的文件偏移。 |
| SHT_REL      | 9          | 该类型节区包含重定位表项（**RELocation entry without Addends**），不过并没有指定位数。例如，32位目标文件中的 Elf32_rel 类型。目标文件中可以拥有多个重定位节区。 |
| SHT_SHLIB    | 10         | 该类型此节区被保留，不过其语义尚未被定义。                    |
| SHT_DYNSYM   | 11         | 作为一个完整的符号表，它可能包含很多对动态链接而言不必  要的符号。因此，目标文件也可以包含一个 SHT_DYNSYM  节区，其中保存动态链接符号的一个最小集合，以节省空间。 |
| SHT_LOPROC   | 0X70000000 | 此值指定保留给处理器专用语义的下界（ **LOw PROCessor-specific semantics** ）。 |
| SHT_HIPROC   | OX7FFFFFFF | 此值指定保留给处理器专用语义的上界（ **HIgh PROCessor-specific semantics** ）。 |
| SHT_LOUSER   | 0X80000000 | 此值指定保留给应用程序的索引下界。                        |
| SHT_HIUSER   | 0X8FFFFFFF | 此值指定保留给应用程序的索引上界。                        |

### sh_flags

节头中 `sh_flags`  字段的每一个比特位都可以给出其相应的标记信息，其定义了对应的节区的内容是否可以被修改、被执行等信息。如果一个标志位被设置，则该位取值为1，未定义的位都为0。目前已定义值如下，其他值保留。

| 名称            | 值          | 说明                                       |
| ------------- | ---------- | ---------------------------------------- |
| SHF_WRITE     | 0x1        | 这种节包含了进程运行过程中可以被写的数据。                    |
| SHF_ALLOC     | 0x2        | 这种节在进程运行时占用内存。对于不占用目标文件的内存镜像空间的某些控制节，该属性处于关闭状态(off)。 |
| SHF_EXECINSTR | 0x4        | 这种节包含可执行的机器指令（**EXECutable INSTRuction**）。 |
| SHF_MASKPROC  | 0xf0000000 | 所有在这个掩码中的比特位用于特定处理器语义。                   |

### sh_link & sh_info

当节区类型的不同的时候，sh_link 和 sh_info 也会具有不同的含义。

| sh_type               | sh_link          | sh_info       |
| --------------------- | ---------------- | ------------- |
| SHT_DYNAMIC           | 节区中使用的字符串表的节头索引  | 0             |
| SHT_HASH              | 此哈希表所使用的符号表的节头索引 | 0             |
| SHT_REL/SHT_RELA      | 与符号表相关的的节头索引     | 重定位应用到的节的节头索引 |
| SHT_SYMTAB/SHT_DYNSYM | 操作系统特定信息         | 操作系统特定信息      |
| other                 | `SHN_UNDEF`      | 0             |

## 特殊节

许多在ELF文件中的节都是预定义的，它们包含程序和控制信息。这些节被操作系统使用，但是对于不同的操作系统可能会有不同的说法。

可执行文件被链接器将一些单独的目标文件以及库文件创建而来。其中，链接器会解析引用，其中包括不同文件中的子例程的引用以及数据的引用，调整对象文件中的绝对引用，并且重定位指令。加载与链接过程需要目标文件中的信息，并且会将处理后的信息存储在一些特定的节区中，比如 `.dynamic` 。

**待补充，，可能得过一段时间了。。。**

# String Table

# Symbol Table

# Relocation
