..


格式化字符串漏洞原理介绍
========================

为了介绍格式化字符串漏洞的原理，会对格式化字符串的利用进行简单介绍。

格式化字符串函数介绍
^^^^^^^^^^^^^^^^^^^^

格式化字符串函数可以接受可变数量的参数，并 **将第一个参数作为格式化字符串，根据其来解析之后的参数** 。通俗来说，格式化字符串函数就是将计算机内存中表示的数据转化为我们人类可读的字符串格式。几乎所有的C/C++程序都会利用格式化字符串函数来 **输出信息，调试程序，或者处理字符串** 。一般来说，格式化字符串在利用的时候主要分为三个部分

-  格式化字符串函数
-  格式化字符串
-  后续参数， **可选**

这里我们给出一个简单的例子，其实相信大多数人都接触过printf函数之类的。之后我们再一个一个进行介绍。

.. figure:: /pwn/fmtstr/figure/printf.png
   :alt: 基本例子

   基本例子

格式化字符串函数
----------------

常见的有格式化字符串函数有

-  输入

-  scanf

-  输出

+----------------------------+------------------------------------------+
| 函数                       | 基本介绍                                 |
+============================+==========================================+
| printf                     | 输出到stdout                             |
+----------------------------+------------------------------------------+
| fprintf                    | 输出到指定FILE流                         |
+----------------------------+------------------------------------------+
| vprintf                    | 根据参数列表格式化输出到 stdout          |
+----------------------------+------------------------------------------+
| vfprintf                   | 根据参数列表格式化输出到指定FILE流       |
+----------------------------+------------------------------------------+
| sprintf                    | 输出到字符串                             |
+----------------------------+------------------------------------------+
| snprintf                   | 输出指定字节数到字符串                   |
+----------------------------+------------------------------------------+
| vsprintf                   | 根据参数列表格式化输出到字符串           |
+----------------------------+------------------------------------------+
| vsnprintf                  | 根据参数列表格式化输出指定字节到字符串   |
+----------------------------+------------------------------------------+
| setproctitle               | 设置argv                                 |
+----------------------------+------------------------------------------+
| syslog                     | 输出日志                                 |
+----------------------------+------------------------------------------+
| err, verr, warn, vwarn等   | 。。。                                   |
+----------------------------+------------------------------------------+

格式化字符串
------------

这里我们了解一下格式化字符串的格式，其基本格式如下

::

    %[parameter][flags][field width][.precision][length]type

每一种pattern的含义如下。

parameter
~~~~~~~~~

+-------+------------------------------------------+
| 字符  | 描述                                     |
+=======+==========================================+
| `n` | *n* 是用这个格式说明符（specifier）显示第几个参数；这使得参数可以输出多次，使用多个格式说明符，以不同的顺序输出。如果任意一个占位符使用了 *parameter* ，则其他所有占位符必须也使用 *parameter* 。这是 `POSIX <https://zh.wikipedia.org/wiki/POSIX>`_ 扩展，不属于 `ISOC <https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80>`__ 。例： ``printf("%2$d %2$#x; %1$d %1$#x",16,17)`` 产生 ``17 0x11; 16 0x10``     |
+-------+------------------------------------------+

flag
~~~~

0个或多个

+-------+------------------------------------------+
| ``+`` | 总是表示有符号数值的 ``+`` 或 ``-`` 号，缺省情况是忽略正数的符号。 |
|       | 仅适用于数值类型。                       |
+=======+==========================================+
| *空格* | 使得有符号数的输出如果没有正负号或者输出0个字符，则前缀1个空格。如果空格与 + |
|       |  同时出现，则空格说明符被忽略。          |
+-------+------------------------------------------+
| ``-`` | 左对齐。缺省情况是右对齐。               |
+-------+------------------------------------------+
| ``#`` | 对于 ``g`` 与 ``G`` ，不删除尾部0以表示精度。对于 ``f`` , |
|       |                                          |
|       |  ``F`` ,  ``e`` ,  ``E`` ,  ``g`` ,      |
|       | ``G`` , 总是输出小数点。对于 ``o`` ,    |
|       | ``x`` ,  ``X`` ,                        |
|       | 在非0数值前分别输出前缀 ``0``, ``0x``,  |
|       | and ``0X`` 表示数制。                   |
+-------+------------------------------------------+
| ``0`` | 如果 *width* 选项前缀以 ``0`` ，则在左侧用\ ``0`` |
|       |  填充直至达到宽度要求。例如 ``printf("%2d", 3)`` 输 |
|       | 出 ``3`` ，而 ``printf("%02d", 3)`` 输出 ``03`` |
|       | 。如果 ``0`` 与 ``-`` 均出现，则 ``0`` 被忽略 |
|       | ，即左对齐依然用空格填充。               |
+-------+------------------------------------------+

filed width
~~~~~~~~~~~

输出最小宽度

-  用十进制整数来表示输出的最少位数。
-  若实际位数多于定义的宽度,则按实际位数输出。
-  若实际位数少于定义的宽度则补以空格或0。

Precision
~~~~~~~~~

通常指明输出的最大长度，依赖于特定的格式化类型。对于d、i、u、x、o的整型数值，是指最小数字位数，不足的位要在左侧补0，如果超过也不截断，缺省值为1。对于a,A,e,E,f,F的浮点数值，是指小数点右边显示的数字位数，必要时四舍五入；缺省值为6。对于g,G的浮点数值，是指 `有效数字 <https://zh.wikipedia.org/wiki/%E6%9C%89%E6%95%88%E6%95%B0%E5%AD%97>`__ 的最大位数。对于s的字符串类型，是指输出的字节的上限，超出限制的其它字符将被截断。如果域宽为 ``*`` ，则由对应的函数参数的值为当前域宽。如果仅给出了小数点，则域宽为0。

length
~~~~~~

+-------+------------------------------------------+
| 字符  | 描述                                     |
+=======+==========================================+
| ``hh` | 对于整数类型， ``printf`` 期待一个从 ``char`` 提升 |
| `     | 的 ``int`` 尺寸的整型参数。            |
+-------+------------------------------------------+
| ``h`` | 对于整数类型， ``printf`` 期待一个从 ``short`` 提 |
|       | 升的 ``int`` 尺寸的整型参数。          |
+-------+------------------------------------------+
| ``l`` | 对于整数类型， ``printf`` 期待一个 ``long`` 尺寸的 |
|       | 整型参数。对于浮点类型， ``printf`` 期待一个 ``double |
|       | `` 尺寸的整型参数。对于字符串s类型， ``printf`` 期待一个 |
|       |  ``wchar_t`` 指针参数。对于字符c类型， ``printf`` |
|       |  期待一个 ``wint_t`` 型的参数。        |
+-------+------------------------------------------+
| ``ll` | 对于整数类型， ``printf`` 期待一个 ``long long`` |
| `     |  尺寸的整型参数。Microsoft也可以使用 ``I64`` 。 |
+-------+------------------------------------------+
| ``L`` | 对于浮点类型， ``printf`` 期待一个 ``long double |
|       | `` 尺寸的整型参数。                     |
+-------+------------------------------------------+
| ``z`` | 对于整数类型， ``printf`` 期待一个 ``size_t`` 尺 |
|       | 寸的整型参数。                           |
+-------+------------------------------------------+
| ``j`` | 对于整数类型， ``printf`` 期待一个 ``intmax_t`` |
|       |  尺寸的整型参数。                        |
+-------+------------------------------------------+
| ``t`` | 对于整数类型， ``printf`` 期待一个 ``ptrdiff_t`` |
|       |  尺寸的整型参数。                       |
+-------+------------------------------------------+

type
~~~~

+-----------+------------------------------------------+
| 字符      | 描述                                     |
+===========+==========================================+
| ``d``,    | 有符号十进制数值 ``int`` 。 ``%d`` 与 ``%i`` 对于输 |
| ``i``     | 出是同义；但对于``scanf()`` 输入二者不同，其中 ``%i``  |
|           | 在输入值有前缀 ``0x`` 或0时，分别表示16进制或8进制的值。如果指定 |
|           | 了精度，则输出的数字不足时在左侧补0。默认精度为1。精度为0且值为0，则输出为空 |
|           | 。                                       |
+-----------+------------------------------------------+
| ``u``     | 十进制 ``unsigned int`` 。如果指定了精度，则输出的数字不足 |
|           | 时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。 |
+-----------+------------------------------------------+
| ``f``,    | ``double`` 型输出10进制 `定点 <https://zh.wik |
| ``F``     | ipedia.org/w/index.php?title=%E5%AE%9A%E |
|           | 7%82%B9&action=edit&redlink=1>`_ 表示。  |
|           | ```f`` 与 ``F`` 差异是表示无穷与NaN时， ``f`` 输出 ``in |
|           | f`` ,                                    |
|           |  ``infinity`` 与 ``nan`` ； ``F`` 输出'``INF |
|           | `` ,                                     |
|           |  ``INFINITY`` 与 ``NAN`` 。小数点后的数字位数等于精度，最 |
|           | 后一位数字`四舍五入 <https://zh.wikipedia.org/wik |
|           | i/%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5>`_ |
|           | 。精度默认为6。如果精度为0且没有#标记，则不出现小数点。小数点左侧至少 |
|           | 一位数字。                               |
+-----------+------------------------------------------+
| ``e``,    | ``double`` 值，输出形式为10进制的([ ``-`` ]d.ddd |
| ``E``     |                                          |
|           | ``e`` [``+``/ ``-`` ]ddd).                |
|           | ``E`` 版本使用的指数符号为 ``E`` （而不是 ``e``\ ） |
|           | 。指数部分至少包含2位数字，如果值为0，则指数部分为 ``00`` 。Win |
|           | dows系统，指数部分至少为3位数字，例如 ``1.5e002`` ，也可用 |
|           | Microsoft版的运行时函数 ``_set_output_format`` |
|           |                                          |
|           | 修改。小数点前存在1位数字。小数点后的数字位数等于精度。精度默认为6。如果精度为 |
|           | 0且没有#标记，则不出现小数点。           |
+-----------+------------------------------------------+
| ``g``,    | ``double`` 型数值，精度定义为全部有效数字位数。当指数部分在 `闭 |
| ``G``     | 区间 <https://zh.wikipedia.org/wiki/%E9%97 |
|           | %AD%E5%8C%BA%E9%97%B4>`_                |
|           | [-4,精度]                                |
|           | 内，输出为定点形式；否则输出为指数浮点形式。 ``g`` 使用小写字母， ``G`` |
|           | 使用大写字母。小数点右侧的尾数0不被显示；显示小数点仅当输出的小数部分不为 |
|           | 0。                                      |
+-----------+------------------------------------------+
| ``x``,    | **16进制 ``unsigned int`` 。 ``x`` 使用小写字母 |
| ``X``     | ； ``X`` 使用大写字母。如果指定了精度，则输出的数字不足时在左侧补0。默认 |
|           | 精度为1。精度为0且值为0，则输出为空。**  |
+-----------+------------------------------------------+
| ``o``     | 8进制 ``unsigned int`` 。如果指定了精度，则输出的数字不足 |
|           | 时在左侧补0。默认精度为1。精度为0且值为0，则输出为空。 |
+-----------+------------------------------------------+
| ``s``     | **如果没有用l标志，输出 `null结尾字符串 <https://zh.wi |
|           | kipedia.org/w/index.php?title=Null%E7%BB |
|           | %93%E5%B0%BE%E5%AD%97%E7%AC%A6%E4%B8%B2& |
|           | action=edit&redlink=1>`_ 直到精度规定的上限；如果没 |
|           | 有指定精度，则输出所有字节。如果用了l标志，则对应函数参数指向wchar_t型 |
|           | 的数组，输出时把每个宽字符转化为多字节字符，相当于调用 ``wcrtomb`` |
|           |  函数。**                               |
+-----------+------------------------------------------+
| ``c``     | 如果没有用l标志，把int参数转为 ``unsigned char`` 型输 |
|           | 出；如果用了l标志，把wint_t参数转为包含两个元素的 ``wchart_ |
|           | t`` 数组，其中第一个元素包含要输出的字符，第二个元素为null宽字符。 |
+-----------+------------------------------------------+
| ``p``     | **``void *`` 型，输出对应变量的值。printf("%p", |
|           |                                          |
|           | a)用地址的格式打印变量a的值，printf("%p", |
|           |                                          |
|           | &a)打印变量a所在的地址。**               |
+-----------+------------------------------------------+
| ``a``,    | ``double`` 型的16进制表示，"[−]0 **x** h.hhh |
| ``A``     | h                                        |
|           | **p** ±d"。其中指数部分为10进制表示的形式。例如：1025.010输 |
|           | 出为0x1.004000p+10。 ``a`` 使用小写字母， ``A`` 使用 |
|           | 大写字母。[`2] <https://zh.wikipedia.org/wiki |
|           | /%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7 |
|           | %AC%A6%E4%B8%B2#cite_note-2>`__ [`3] <h |
|           | ttps://zh.wikipedia.org/wiki/%E6%A0%BC%E |
|           | 5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8 |
|           | %B2#cite_note-3>`_                 |
|           | （C++11流使用 ``hexfloat`` 输出16进制浮点数） |
+-----------+------------------------------------------+
| ``n``     | **不输出字符，但是把已经成功输出的字符个数写入对应的整型指针参数所指的变量。* |
|           | *                                        |
+-----------+------------------------------------------+
| ``%``     |  ``%`` 字面值，不接受任何flags, width,   |
|           | precision or length。                    |
+-----------+------------------------------------------+

上面加黑的为比较有用的信息。

参数
----

就是相应的要输出的变量。

格式化字符串漏洞原理
^^^^^^^^^^^^^^^^^^^^

在一开始，我们就给出格式化字符串的基本介绍，这里再说一些比较细致的内容。我们上面说，格式化字符串函数是根据格式化字符串函数来进行解析的。 **那么相应的要被解析的参数的个数也自然是由这个格式化字符串所控制** 。比如说 %s'表明我们会输出一个字符串参数。

我们再继续以上面的为例子进行介绍

.. figure:: /pwn/fmtstr/figure/printf.png
   :alt: 基本例子

对于这样的例子，在进入printf函数的之前(即还没有调用printf)，栈上的布局由高地址到低地址依次如下

.. code:: text

    some value
    3.14
    123456
    addr of "red"
    addr of format string: Color %s...

**注：这里我们假设3.14上面的值为某个未知的值。**

在进入printf之后，函数首先获取第一个参数，一个一个读取其字符会遇到两种情况

-  当前字符不是%，直接输出到相应标准输出。
-  当前字符是%， 继续读取下一个字符
-  如果没有字符，报错
-  如果下一个字符是%,输出%
-  否则根据相应的字符，获取相应的参数，对其进行解析并输出

那么假设，此时我们在编写程序时候，写成了下面的样子

.. code:: c

    printf("Color %s, Number %d, Float %4.2f");

此时我们可以发现我们并没有提供参数，那么程序会如何运行呢？程序照样会运行，会将栈上存储格式化字符串地址上面的三个变量分别解析为

1. 解析其地址对应的字符串
2. 解析其内容对应的整形值
3. 解析其内容对应的浮点值

对于2，3来说倒还无妨，但是对于对于1来说，如果提供了一个不可访问地址，比如0，那么程序就会因此而崩溃。

这基本就是格式化字符串漏洞的基本原理了。

参考阅读
^^^^^^^^^^^^

-  https://zh.wikipedia.org/wiki/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2
