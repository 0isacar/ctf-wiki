

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>深入理解堆的实现 &mdash; CTF Wiki  文档</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="索引"
              href="../../genindex.html"/>
        <link rel="search" title="搜索" href="../../search.html"/>
    <link rel="top" title="CTF Wiki  文档" href="../../index.html"/>
        <link rel="up" title="堆利用" href="index.html"/>
        <link rel="next" title="堆溢出" href="heapoverflow_basic.html"/>
        <link rel="prev" title="堆相关数据结构" href="heap_structure.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> CTF Wiki
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">CTF 介绍</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/history.html">CTF 竞赛的历史</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/mode.html">CTF 竞赛模式简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/content.html">CTF 竞赛内容</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/experience.html">线下攻防经验小结</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/cgc.html">CGC 网络超级挑战赛</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/resources.html">学习资源</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/about.html">Misc综述</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/recon.html">信息搜集技术</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/encode/index.html">编码分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/prefix.html">取证隐写</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/picture/index.html">图片分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/archive/index.html">压缩包分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/audio/index.html">音频分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/disk_memory/index.html">磁盘 / 内存分析</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/cap.html">流量分析</a></li>
</ul>
<p class="caption"><span class="caption-text">Crypto</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/introduction.html">密码学简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/classical/index.html">古典密码</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/symmetric/index.html">对称加密</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/asymmetric/index.html">非对称密码</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/hash/index.html">哈希函数</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/signature/index.html">数字签名</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/others/others.html">证书格式</a></li>
</ul>
<p class="caption"><span class="caption-text">Web</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../web/index.html">WEB 简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/sqli.html">SQL 注入</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/xss.html">XSS 跨站脚本攻击</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/csrf.html">CSRF 跨站请求伪造</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/ssrf.html">SSRF 服务端请求伪造</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../web/php.html">PHP 代码审计</a></li>
</ul>
<p class="caption"><span class="caption-text">Reverse</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../reverse/index.html">Reverse Engineering</a></li>
</ul>
<p class="caption"><span class="caption-text">Pwn</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../stackoverflow/index.html">栈溢出</a></li>
<li class="toctree-l1"><a class="reference internal" href="../fmtstr/index.html">格式化字符串漏洞</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">堆利用</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="heap_basic_intro.html">基本堆介绍</a></li>
<li class="toctree-l2"><a class="reference internal" href="heap_structure.html">堆相关数据结构</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">深入理解堆的实现</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id2">堆初始化</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id3">创建堆</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id4">申请内存块</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#libc-malloc">__libc_malloc</a></li>
<li class="toctree-l4"><a class="reference internal" href="#int-malloc">_int_malloc</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sysmalloc">sysmalloc</a></li>
<li class="toctree-l4"><a class="reference internal" href="#malloc-consolidate">malloc_consolidate</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id12">释放内存块</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#libc-free">__libc_free</a></li>
<li class="toctree-l4"><a class="reference internal" href="#int-free">_int_free</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unlink">unlink</a></li>
<li class="toctree-l4"><a class="reference internal" href="#systrim">systrim</a></li>
<li class="toctree-l4"><a class="reference internal" href="#heap-trim">heap_trim</a></li>
<li class="toctree-l4"><a class="reference internal" href="#munmap-chunk">munmap_chunk</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id21">删除堆</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="heapoverflow_basic.html">堆溢出</a></li>
<li class="toctree-l2"><a class="reference internal" href="use_after_free.html">Use After Free</a></li>
<li class="toctree-l2"><a class="reference internal" href="off_by_one.html">堆中的off-by-one</a></li>
<li class="toctree-l2"><a class="reference internal" href="fastbin_attack.html">fastbin attack</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Executable</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../executable/elf/index.html">ELF文件</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">CTF Wiki</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">堆利用</a> &raquo;</li>
        
      <li>深入理解堆的实现</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/pwn/heap/heap_implementation_details.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>深入理解堆的实现<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>简单想一下，对于任何堆的实现来说都离不开以下的问题</p>
<ul class="simple">
<li>宏观角度</li>
<li>创建堆并对堆进行初始化</li>
<li>删除堆</li>
<li>微观角度</li>
<li>申请内存块</li>
<li>释放内存块</li>
</ul>
<p>当然，这些都是一些比较高层面的想法，对于一些底层的实现来说，会有所不同。</p>
<div class="section" id="id2">
<h2>堆初始化<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
</div>
<div class="section" id="id3">
<h2>创建堆<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
</div>
<div class="section" id="id4">
<h2>申请内存块<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>我们之前也说了，我们会使用malloc函数来申请内存块，可是当我们仔细看看glibc的源码实现时，其实并没有malloc函数。其实该函数真正调用的是__libc_malloc函数。为什么不直接写个malloc函数呢，因为有时候我们可能需要不同的名称，而且该函数只是用来简单封装_int_malloc函数。_int_malloc
才是申请内存块的核心。下面我们来仔细分析一下实现。</p>
<div class="section" id="libc-malloc">
<h3>__libc_malloc<a class="headerlink" href="#libc-malloc" title="永久链接至标题">¶</a></h3>
<ol class="arabic simple">
<li>该函数会首先检查是否有内存分配函数的钩子函数。该函数主要用于进程在创建新线程过程中分配内存或者用户自定义的分配函数。</li>
</ol>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>// wapper for int_malloc
void *__libc_malloc(size_t bytes) {
    mstate ar_ptr;
    void * victim;
    // 检查是否有内存分配钩子，如果有，调用钩子并返回.
    void *(*hook)(size_t, const void *) = atomic_forced_read(__malloc_hook);
    if (__builtin_expect(hook != NULL, 0))
        return (*hook)(bytes, RETURN_ADDRESS(0));
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>接着会寻找一个arena来试图分配内存。</li>
</ol>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="n">arena_get</span><span class="p">(</span><span class="n">ar_ptr</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">);</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li>然后调用_int_malloc函数去申请对应的内存。</li>
</ol>
<div class="code c++ highlight-default"><div class="highlight"><pre><span></span><span class="n">victim</span> <span class="o">=</span> <span class="n">_int_malloc</span><span class="p">(</span><span class="n">ar_ptr</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">);</span>
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li>如果分配失败的话，ptmalloc会尝试再去寻找一个可用的arena，并分配内存。</li>
</ol>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/* Retry with another arena only if we were able to find a usable arena
   before.  */
if (!victim &amp;&amp; ar_ptr != NULL) {
    LIBC_PROBE(memory_malloc_retry, 1, bytes);
    ar_ptr = arena_get_retry(ar_ptr, bytes);
    victim = _int_malloc(ar_ptr, bytes);
}
</pre></div>
</div>
<ol class="arabic simple" start="5">
<li>如果申请到了arena，那么在离开之前还得解锁。</li>
</ol>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">ar_ptr</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">)</span> <span class="n">__libc_lock_unlock</span><span class="p">(</span><span class="n">ar_ptr</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</pre></div>
</div>
<ol class="arabic simple" start="6">
<li>判断目前的状态是否满足以下条件，要么没有申请到内存，要么是mmap的内存，<strong>要么申请到的内存必须在其所分配的arena中</strong>。</li>
</ol>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>assert(!victim || chunk_is_mmapped(mem2chunk(victim)) ||
       ar_ptr == arena_for_chunk(mem2chunk(victim)));
</pre></div>
</div>
<ol class="arabic simple" start="7">
<li>最后返回内存。</li>
</ol>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>    <span class="k">return</span> <span class="n">victim</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="int-malloc">
<h3>_int_malloc<a class="headerlink" href="#int-malloc" title="永久链接至标题">¶</a></h3>
<div class="section" id="id5">
<h4>概述<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h4>
<p>_int_malloc时内存分配的核心函数，其核心思路有以下几点</p>
<ol class="arabic simple">
<li>它根据用户申请的内存块的大小，依次实现了不同的分配方法。</li>
<li>它会首先检查申请的内存块是不是有相应的空闲块可以满足需求，没有的话，才会进行内存块申请。</li>
<li>它会按照chunk 的大小由小到大依次判断。</li>
</ol>
</div>
<div class="section" id="id6">
<h4>初始<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h4>
<p>在进入该函数后，函数立马定义了一系列自己需要的变量，并在开始时，将用户申请的内存大小转换为其chunk大小。</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">void</span> <span class="o">*</span><span class="n">_int_malloc</span><span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">,</span> <span class="n">size_t</span> <span class="nb">bytes</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">INTERNAL_SIZE_T</span> <span class="n">nb</span><span class="p">;</span>  <span class="o">/*</span> <span class="n">normalized</span> <span class="n">request</span> <span class="n">size</span> <span class="o">*/</span>
    <span class="n">unsigned</span> <span class="nb">int</span>    <span class="n">idx</span><span class="p">;</span> <span class="o">/*</span> <span class="n">associated</span> <span class="nb">bin</span> <span class="n">index</span> <span class="o">*/</span>
    <span class="n">mbinptr</span>         <span class="nb">bin</span><span class="p">;</span> <span class="o">/*</span> <span class="n">associated</span> <span class="nb">bin</span> <span class="o">*/</span>

    <span class="n">mchunkptr</span>       <span class="n">victim</span><span class="p">;</span>       <span class="o">/*</span> <span class="n">inspected</span><span class="o">/</span><span class="n">selected</span> <span class="n">chunk</span> <span class="o">*/</span>
    <span class="n">INTERNAL_SIZE_T</span> <span class="n">size</span><span class="p">;</span>         <span class="o">/*</span> <span class="n">its</span> <span class="n">size</span> <span class="o">*/</span>
    <span class="nb">int</span>             <span class="n">victim_index</span><span class="p">;</span> <span class="o">/*</span> <span class="n">its</span> <span class="nb">bin</span> <span class="n">index</span> <span class="o">*/</span>

    <span class="n">mchunkptr</span>     <span class="n">remainder</span><span class="p">;</span>      <span class="o">/*</span> <span class="n">remainder</span> <span class="kn">from</span> <span class="nn">a</span> <span class="n">split</span> <span class="o">*/</span>
    <span class="n">unsigned</span> <span class="n">long</span> <span class="n">remainder_size</span><span class="p">;</span> <span class="o">/*</span> <span class="n">its</span> <span class="n">size</span> <span class="o">*/</span>

    <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">block</span><span class="p">;</span> <span class="o">/*</span> <span class="n">bit</span> <span class="nb">map</span> <span class="n">traverser</span> <span class="o">*/</span>
    <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">bit</span><span class="p">;</span>   <span class="o">/*</span> <span class="n">bit</span> <span class="nb">map</span> <span class="n">traverser</span> <span class="o">*/</span>
    <span class="n">unsigned</span> <span class="nb">int</span> <span class="nb">map</span><span class="p">;</span>   <span class="o">/*</span> <span class="n">current</span> <span class="n">word</span> <span class="n">of</span> <span class="n">binmap</span> <span class="o">*/</span>

    <span class="n">mchunkptr</span> <span class="n">fwd</span><span class="p">;</span> <span class="o">/*</span> <span class="n">misc</span> <span class="n">temp</span> <span class="k">for</span> <span class="n">linking</span> <span class="o">*/</span>
    <span class="n">mchunkptr</span> <span class="n">bck</span><span class="p">;</span> <span class="o">/*</span> <span class="n">misc</span> <span class="n">temp</span> <span class="k">for</span> <span class="n">linking</span> <span class="o">*/</span>

    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">errstr</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>

    <span class="o">/*</span>
       <span class="n">Convert</span> <span class="n">request</span> <span class="n">size</span> <span class="n">to</span> <span class="n">internal</span> <span class="n">form</span> <span class="n">by</span> <span class="n">adding</span> <span class="n">SIZE_SZ</span> <span class="nb">bytes</span>
       <span class="n">overhead</span> <span class="n">plus</span> <span class="n">possibly</span> <span class="n">more</span> <span class="n">to</span> <span class="n">obtain</span> <span class="n">necessary</span> <span class="n">alignment</span> <span class="ow">and</span><span class="o">/</span><span class="ow">or</span>
       <span class="n">to</span> <span class="n">obtain</span> <span class="n">a</span> <span class="n">size</span> <span class="n">of</span> <span class="n">at</span> <span class="n">least</span> <span class="n">MINSIZE</span><span class="p">,</span> <span class="n">the</span> <span class="n">smallest</span> <span class="n">allocatable</span>
       <span class="n">size</span><span class="o">.</span> <span class="n">Also</span><span class="p">,</span> <span class="n">checked_request2size</span> <span class="n">traps</span> <span class="p">(</span><span class="n">returning</span> <span class="mi">0</span><span class="p">)</span> <span class="n">request</span> <span class="n">sizes</span>
       <span class="n">that</span> <span class="n">are</span> <span class="n">so</span> <span class="n">large</span> <span class="n">that</span> <span class="n">they</span> <span class="n">wrap</span> <span class="n">around</span> <span class="n">zero</span> <span class="n">when</span> <span class="n">padded</span> <span class="ow">and</span>
       <span class="n">aligned</span><span class="o">.</span>
     <span class="o">*/</span>

    <span class="n">checked_request2size</span><span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="n">nb</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="arena">
<h4>判断是否有arena可用<a class="headerlink" href="#arena" title="永久链接至标题">¶</a></h4>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">There</span> <span class="n">are</span> <span class="n">no</span> <span class="n">usable</span> <span class="n">arenas</span><span class="o">.</span>  <span class="n">Fall</span> <span class="n">back</span> <span class="n">to</span> <span class="n">sysmalloc</span> <span class="n">to</span> <span class="n">get</span> <span class="n">a</span> <span class="n">chunk</span> <span class="kn">from</span>
   <span class="nn">mmap.</span>  <span class="o">*/</span>
<span class="k">if</span> <span class="p">(</span><span class="n">__glibc_unlikely</span><span class="p">(</span><span class="n">av</span> <span class="o">==</span> <span class="n">NULL</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">sysmalloc</span><span class="p">(</span><span class="n">nb</span><span class="p">,</span> <span class="n">av</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">NULL</span><span class="p">)</span> <span class="n">alloc_perturb</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="fast-bin">
<h4>fast bin<a class="headerlink" href="#fast-bin" title="永久链接至标题">¶</a></h4>
<p>如果申请的chunk的大小位于fastbin 范围内</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/*
   If the size qualifies as a fastbin, first check corresponding bin.
   This code is safe to execute even if av is not yet initialized, so we
   can try it without checking, which saves some time on this fast path.
 */

if ((unsigned long) (nb) &lt;= (unsigned long) (get_max_fast())) {
    // 得到对应的fastbin的下标
    idx             = fastbin_index(nb);
    // 得到对应的fastbin的头指针
    mfastbinptr *fb = &amp;fastbin(av, idx);
    mchunkptr    pp = *fb;
    // 检查对应的bin内是否有空闲的chunk块，
    do {
        victim = pp;
        if (victim == NULL) break;
    } while ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd,
                                                        victim)) != victim);
    // 存在可以利用的chunk
    if (victim != 0) {
        // 检查取到的chunk是否确实在对应的fastbin中。
        if (__builtin_expect(fastbin_index(chunksize(victim)) != idx, 0)) {
            errstr = &quot;malloc(): memory corruption (fast)&quot;;
        errout:
            malloc_printerr(check_action, errstr, chunk2mem(victim), av);
            return NULL;
        }
        // 细致的检查。。
        check_remalloced_chunk(av, victim, nb);
        // 将获取的到chunk转换为mem模式
        void *p = chunk2mem(victim);
        // 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff
        alloc_perturb(p, bytes);
        return p;
    }
}
</pre></div>
</div>
</div>
<div class="section" id="small-bin">
<h4>small bin<a class="headerlink" href="#small-bin" title="永久链接至标题">¶</a></h4>
<p>如果获取的内存块的范围处于small bin的范围，那么执行如下流程</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/*
   If a small request, check regular bin.  Since these &quot;smallbins&quot;
   hold one size each, no searching within bins is necessary.
   (For a large request, we need to wait until unsorted chunks are
   processed to find best fit. But for small ones, fits are exact
   anyway, so we can check now, which is faster.)
 */

if (in_smallbin_range(nb)) {
    // 获取small bin的索引
    idx = smallbin_index(nb);
    // 获取对应small bin中的chunk指针
    bin = bin_at(av, idx);
    // 先执行victim= last(bin)
    // 如果victim = bin，那说明该bin为空。
    // 如果不相等，那么会有两种情况
    if ((victim = last(bin)) != bin) {
        // 第一种情况，该bin还没有初始化。
        if (victim == 0) /* initialization check */
            // 执行初始化，将fast bins中的chunk进行合并
            malloc_consolidate(av);
        // 第二种情况，该bin中存在空闲的chunk
        else {
            // 获取该bin中最后一个chunk。
            bck = victim-&gt;bk;
            // 检查bck中记录的前一个chunk是不是victim，防止伪造
            if (__glibc_unlikely(bck-&gt;fd != victim)) {
                errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;
                goto errout;
            }
            // 设置与victim对应的inuse位
            set_inuse_bit_at_offset(victim, nb);
            // 修改bin的链表情况
            bin-&gt;bk = bck;
            bck-&gt;fd = bin;
            // 如果不是主arena，设置对应的标志
            if (av != &amp;main_arena) set_non_main_arena(victim);
            // 细致的检查
            check_malloced_chunk(av, victim, nb);
            // 将申请到的chunk转化为对应的mem状态
            void *p = chunk2mem(victim);
            // 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff
            alloc_perturb(p, bytes);
            return p;
        }
    }
}
</pre></div>
</div>
</div>
<div class="section" id="large-bin">
<h4>large bin<a class="headerlink" href="#large-bin" title="永久链接至标题">¶</a></h4>
<p>large bin的处理过程如下</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/*
   If this is a large request, consolidate fastbins before continuing.
   While it might look excessive to kill all fastbins before
   even seeing if there is space available, this avoids
   fragmentation problems normally associated with fastbins.
   Also, in practice, programs tend to have runs of either small or
   large requests, but less often mixtures, so consolidation is not
   invoked all that often in most programs. And the programs that
   it is called frequently in otherwise tend to fragment.
 */

else {
    // 获取large bin的下标。
    idx = largebin_index(nb);
    // 如果存在fastbin的话，会先对fastbin进行合并，将其加入到unsorted bin中
    if (have_fastchunks(av)) malloc_consolidate(av);
}
</pre></div>
</div>
</div>
<div class="section" id="id7">
<h4>循环<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h4>
<div class="section" id="id8">
<h5>概述<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h5>
<p><strong>上面说明没有bin可以直接满足需求</strong>。在接下来的这个循环中，主要做了以下的操作</p>
<ul class="simple">
<li>尝试从unsorted bin中分配用户所需的内存</li>
<li>尝试从large bin中分配用户所需的内存</li>
<li>尝试从top chunk中分配用户所需内存</li>
</ul>
</div>
<div class="section" id="id9">
<h5>大循环<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h5>
<p>该部分是一个大循环，这是为了尝试重新分配small bin chunk，这是因为我们虽然会首先使用large bin，top chunk来尝试满足用户的请求，但是如果没有满足的话，由于我们在上面没有分配成功small
bin的话，我们并没有对fast bin中的chunk进行合并，所以这里会进行fast bin chunk的合并，进而使用一个大循环来尝试再次分配small bin chunk。</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span>
   <span class="n">Process</span> <span class="n">recently</span> <span class="n">freed</span> <span class="ow">or</span> <span class="n">remaindered</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">taking</span> <span class="n">one</span> <span class="n">only</span> <span class="k">if</span>
   <span class="n">it</span> <span class="ow">is</span> <span class="n">exact</span> <span class="n">fit</span><span class="p">,</span> <span class="ow">or</span><span class="p">,</span> <span class="k">if</span> <span class="n">this</span> <span class="n">a</span> <span class="n">small</span> <span class="n">request</span><span class="p">,</span> <span class="n">the</span> <span class="n">chunk</span> <span class="ow">is</span> <span class="n">remainder</span> <span class="kn">from</span>
   <span class="nn">the</span> <span class="n">most</span> <span class="n">recent</span> <span class="n">non</span><span class="o">-</span><span class="n">exact</span> <span class="n">fit</span><span class="o">.</span>  <span class="n">Place</span> <span class="n">other</span> <span class="n">traversed</span> <span class="n">chunks</span> <span class="ow">in</span>
   <span class="n">bins</span><span class="o">.</span>  <span class="n">Note</span> <span class="n">that</span> <span class="n">this</span> <span class="n">step</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">only</span> <span class="n">place</span> <span class="ow">in</span> <span class="nb">any</span> <span class="n">routine</span> <span class="n">where</span>
   <span class="n">chunks</span> <span class="n">are</span> <span class="n">placed</span> <span class="ow">in</span> <span class="n">bins</span><span class="o">.</span>

   <span class="n">The</span> <span class="n">outer</span> <span class="n">loop</span> <span class="n">here</span> <span class="ow">is</span> <span class="n">needed</span> <span class="n">because</span> <span class="n">we</span> <span class="n">might</span> <span class="ow">not</span> <span class="n">realize</span> <span class="n">until</span>
   <span class="n">near</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span> <span class="n">malloc</span> <span class="n">that</span> <span class="n">we</span> <span class="n">should</span> <span class="n">have</span> <span class="n">consolidated</span><span class="p">,</span> <span class="n">so</span> <span class="n">must</span>
   <span class="n">do</span> <span class="n">so</span> <span class="ow">and</span> <span class="n">retry</span><span class="o">.</span> <span class="n">This</span> <span class="n">happens</span> <span class="n">at</span> <span class="n">most</span> <span class="n">once</span><span class="p">,</span> <span class="ow">and</span> <span class="n">only</span> <span class="n">when</span> <span class="n">we</span> <span class="n">would</span>
   <span class="n">otherwise</span> <span class="n">need</span> <span class="n">to</span> <span class="n">expand</span> <span class="n">memory</span> <span class="n">to</span> <span class="n">service</span> <span class="n">a</span> <span class="s2">&quot;small&quot;</span> <span class="n">request</span><span class="o">.</span>
 <span class="o">*/</span>

<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
    <span class="nb">int</span> <span class="n">iters</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="unsort-bin-last-remainder">
<h5>unsort bin &amp; last remainder<a class="headerlink" href="#unsort-bin-last-remainder" title="永久链接至标题">¶</a></h5>
<p>先考虑unsorted bin，在考虑last remainder，但是对于small bin chunk的请求会有所例外。</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>        // 如果unsorted bin不为空
        // First In First Out
        while ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av)) {
            // 得到 unsorted bin的最后一个chunk
            bck = victim-&gt;bk;
            // 判断得到的chunk是否满足要求，不能过小，也不能过大
            if (__builtin_expect(chunksize_nomask(victim) &lt;= 2 * SIZE_SZ, 0) ||
                __builtin_expect(chunksize_nomask(victim) &gt; av-&gt;system_mem, 0))
                malloc_printerr(check_action, &quot;malloc(): memory corruption&quot;,
                                chunk2mem(victim), av);
            // 得到victim对应的chunk大小。
            size = chunksize(victim);

            /*
               If a small request, try to use last remainder if it is the
               only chunk in unsorted bin.  This helps promote locality for
               runs of consecutive small requests. This is the only
               exception to best-fit, and applies only when there is
               no exact fit for a small chunk.
             */
            // 如果用户的请求为 small bin chunk，那么我们首先考虑last remainder
            // 如果last remainder是unsorted bin中的唯一一块的话
            // 并且last remainder的大小分割够还可以作为一个chunk，为什么没有等号？
            if (in_smallbin_range(nb) &amp;&amp; bck == unsorted_chunks(av) &amp;&amp;
                victim == av-&gt;last_remainder &amp;&amp;
                (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE)) {
                /* split and reattach remainder */
                // 获取新的remainder的大小
                remainder_size          = size - nb;
                // 获取新的remainder的位置
                remainder               = chunk_at_offset(victim, nb);
                // 更新unsorted bin的情况
                unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;
                // 更新av中记录的last_remainder
                av-&gt;last_remainder                                = remainder;
                // 更新last remainder的指针
                remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);
                if (!in_smallbin_range(remainder_size)) {
                    remainder-&gt;fd_nextsize = NULL;
                    remainder-&gt;bk_nextsize = NULL;
                }
                // 设置victim的头部，
                set_head(victim, nb | PREV_INUSE |
                                     (av != &amp;main_arena ? NON_MAIN_ARENA : 0));
                // 设置remainder的头部
                set_head(remainder, remainder_size | PREV_INUSE);
                // 设置记录 remainder大小的prev_size字段，因为此时remainder处于空闲状态。
                set_foot(remainder, remainder_size);
                // 细致的检查
                check_malloced_chunk(av, victim, nb);
                // 将victim从chunk模式转化为mem模式
                void *p = chunk2mem(victim);
                // 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff
                alloc_perturb(p, bytes);
                return p;
            }
            //
            /* remove from unsorted list */
            unsorted_chunks(av)-&gt;bk = bck;
            bck-&gt;fd                 = unsorted_chunks(av);

            /* Take now instead of binning if exact fit */
            // 如果unsorted bin中的chunk大小正好合适，就直接使用
            if (size == nb) {
                set_inuse_bit_at_offset(victim, size);
                if (av != &amp;main_arena) set_non_main_arena(victim);
                check_malloced_chunk(av, victim, nb);
                void *p = chunk2mem(victim);
                alloc_perturb(p, bytes);
                return p;
            }

            /* place chunk in bin */
            // 把chunk放到对应的bin中
            // small bin范围
            if (in_smallbin_range(size)) {
                victim_index = smallbin_index(size);
                bck          = bin_at(av, victim_index);
                fwd          = bck-&gt;fd;
            } else {
                // large bin范围
                victim_index = largebin_index(size);
                bck          = bin_at(av, victim_index);
                fwd          = bck-&gt;fd;

                /* maintain large bins in sorted order */
                if (fwd != bck) {
                    /* Or with inuse bit to speed comparisons */
                    size |= PREV_INUSE;
                    /* if smaller than smallest, bypass loop below */
                    assert(chunk_main_arena(bck-&gt;bk));
                    if ((unsigned long) (size) &lt;
                        (unsigned long) chunksize_nomask(bck-&gt;bk)) {
                        fwd = bck;
                        bck = bck-&gt;bk;

                        victim-&gt;fd_nextsize = fwd-&gt;fd;
                        victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;
                        fwd-&gt;fd-&gt;bk_nextsize =
                            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;
                    } else {
                        assert(chunk_main_arena(fwd));
                        while ((unsigned long) size &lt; chunksize_nomask(fwd)) {
                            fwd = fwd-&gt;fd_nextsize;
                            assert(chunk_main_arena(fwd));
                        }

                        if ((unsigned long) size ==
                            (unsigned long) chunksize_nomask(fwd))
                            /* Always insert in the second position.  */
                            fwd = fwd-&gt;fd;
                        else {
                            victim-&gt;fd_nextsize              = fwd;
                            victim-&gt;bk_nextsize              = fwd-&gt;bk_nextsize;
                            fwd-&gt;bk_nextsize                 = victim;
                            victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;
                        }
                        bck = fwd-&gt;bk;
                    }
                } else
                    victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;
            }
            // 放到对应的bin中
            mark_bin(av, victim_index);
            victim-&gt;bk = bck;
            victim-&gt;fd = fwd;
            fwd-&gt;bk    = victim;
            bck-&gt;fd    = victim;
            // 最多迭代10000次
##define MAX_ITERS 10000
            if (++iters &gt;= MAX_ITERS) break;
        }
</pre></div>
</div>
</div>
<div class="section" id="large-chunk">
<h5>large chunk<a class="headerlink" href="#large-chunk" title="永久链接至标题">¶</a></h5>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/*
   If a large request, scan through the chunks of current bin in
   sorted order to find smallest that fits.  Use the skip list for this.
 */
// 如果请求的chunk在large chunk范围内，就在对应的bin中从小到大进行扫描，找到第一个合适的
if (!in_smallbin_range(nb)) {
    bin = bin_at(av, idx);

    /* skip scan if empty or largest chunk is too small */
    // 如果 对应的bin为空或者其中的chunk最大的也很小，那就跳过
    // first(bin)=bin-&gt;fd 表示当前链表中最大的chunk
    if ((victim = first(bin)) != bin &amp;&amp;
        (unsigned long) chunksize_nomask(victim) &gt;=
            (unsigned long) (nb)) {
        // 反向遍历链表，直到找到第一个不小于所需chunk大小的chunk
        victim = victim-&gt;bk_nextsize;
        while (((unsigned long) (size = chunksize(victim)) &lt;
                (unsigned long) (nb)))
            victim = victim-&gt;bk_nextsize;

        /* Avoid removing the first entry for a size so that the skip
           list does not have to be rerouted.  */
        // 如果最终取到的chunk不是该bin中的最后一个chunk，并且该chunk与其前面的chunk
        // 的大小相同，那么我们就取其前面的chunk，这样可以避免调整bk_nextsize,fd_nextsize
        //  链表。因为大小相同的chunk只有一个会被串在nextsize链上。
        if (victim != last(bin) &amp;&amp;
            chunksize_nomask(victim) == chunksize_nomask(victim-&gt;fd))
            victim = victim-&gt;fd;
        // 计算分配后剩余的大小
        remainder_size = size - nb;
        // 进行unlink
        unlink(av, victim, bck, fwd);

        /* Exhaust */
        // 剩下的大小不足以当做一个块
        // 很好奇接下来会怎么办？
        if (remainder_size &lt; MINSIZE) {
            set_inuse_bit_at_offset(victim, size);
            if (av != &amp;main_arena) set_non_main_arena(victim);
        }
        /* Split */
        //  剩下的大小还可以作为一个chunk，进行分割。
        else {
            // 获取剩下那部分chunk的指针，称为remainder
            remainder = chunk_at_offset(victim, nb);
            /* We cannot assume the unsorted list is empty and therefore
               have to perform a complete insert here.  */
            // 插入unsorted bin中
            bck = unsorted_chunks(av);
            fwd = bck-&gt;fd;
            if (__glibc_unlikely(fwd-&gt;bk != bck)) {
                errstr = &quot;malloc(): corrupted unsorted chunks&quot;;
                goto errout;
            }
            remainder-&gt;bk = bck;
            remainder-&gt;fd = fwd;
            bck-&gt;fd       = remainder;
            fwd-&gt;bk       = remainder;
            // 如果处于small bin范围内，就设置对应的字段
            if (!in_smallbin_range(remainder_size)) {
                remainder-&gt;fd_nextsize = NULL;
                remainder-&gt;bk_nextsize = NULL;
            }
            // 设置分配的chunk的标记
            set_head(victim,
                     nb | PREV_INUSE |
                         (av != &amp;main_arena ? NON_MAIN_ARENA : 0));

            // 设置remainder的使用状态，其余的不用管，直接从上面继承下来了
            // 为什么这里也设置了inuse？
            set_head(remainder, remainder_size | PREV_INUSE);
            // 设置remainder的大小
            set_foot(remainder, remainder_size);
        }
        // 检查
        check_malloced_chunk(av, victim, nb);
        // 转换为mem状态
        void *p = chunk2mem(victim);
        // 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff
        alloc_perturb(p, bytes);
        return p;
    }
}
</pre></div>
</div>
</div>
<div class="section" id="id10">
<h5>暂时转换<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h5>
<p>如果走到了这里，那说明对于用户所需的chunk，不能直接从其对应的合适的bin中获取chunk，所以我们需要来查找比当前bin更大的fast bin，small bin或者large bin。</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/*
   Search for a chunk by scanning bins, starting with next largest
   bin. This search is strictly by best-fit; i.e., the smallest
   (with ties going to approximately the least recently used) chunk
   that fits is selected.

   The bitmap avoids needing to check that most blocks are nonempty.
   The particular case of skipping all bins during warm-up phases
   when no chunks have been returned yet is faster than it might look.
 */

++idx;
// 获取对应的bin
bin   = bin_at(av, idx);
// 获取当前索引在binmap中的block索引
// #define idx2block(i) ((i) &gt;&gt; BINMAPSHIFT)  ,BINMAPSHIFT=5
// Binmap按block管理，每个block为一个int，共32个bit，可以表示32个bin中是否有空闲chunk存在
// 所以这里是右移5
block = idx2block(idx);
// 获取当前块大小对应的映射，这里可以得知相应的bin中是否有空闲块
map   = av-&gt;binmap[ block ];
// #define idx2bit(i) ((1U &lt;&lt; ((i) &amp; ((1U &lt;&lt; BINMAPSHIFT) - 1))))
// 将idx对应的比特位设置为1，其它位为0
bit   = idx2bit(idx);
</pre></div>
</div>
</div>
<div class="section" id="id11">
<h5>小循环<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h5>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>for (;;) {
    /* Skip rest of block if there are no more set bits in this block.
     */
    // 如果bit&gt;map，则表示该map中没有比当前所需要chunk大的空闲块
    // 如果bit为0，那么说明，上面idx2bit带入的参数为0。
    if (bit &gt; map || bit == 0) {
        do {
            // 寻找下一个block，直到其对应的map不为0。
            // 如果已经不存在的话，那就只能使用top chunk了
            if (++block &gt;= BINMAPSIZE) /* out of bins */
                goto use_top;
        } while ((map = av-&gt;binmap[ block ]) == 0);
        // 获取其对应的bin，因为该map中的chunk大小都比所需的chunk大，而且
        // map本身不为0，所以必然存在瞒住需求的chunk。
        bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));
        bit = 1;
    }

    /* Advance to bin with set bit. There must be one. */
    // 从当前map的最小的bin一直找，直到找到合适的bin。
    // 这里是一定存在的
    while ((bit &amp; map) == 0) {
        bin = next_bin(bin);
        bit &lt;&lt;= 1;
        assert(bit != 0);
    }

    /* Inspect the bin. It is likely to be non-empty */
    // 获取对应的bin
    victim = last(bin);

    /*  If a false alarm (empty bin), clear the bit. */
    // 如果victim=bin，那么我们就将map对应的位清0，然后获取下一个bin
    // 这种情况发生的概率应该很小。
    if (victim == bin) {
        av-&gt;binmap[ block ] = map &amp;= ~bit; /* Write through */
        bin                 = next_bin(bin);
        bit &lt;&lt;= 1;
    }

    else {
        //获取对应victim的大小
        size = chunksize(victim);

        /*  We know the first chunk in this bin is big enough to use. */
        assert((unsigned long) (size) &gt;= (unsigned long) (nb));
        // 计算分割后剩余的大小
        remainder_size = size - nb;

        /* unlink */
        unlink(av, victim, bck, fwd);

        /* Exhaust */
        // 如果分割后不够一个chunk怎么办？
        if (remainder_size &lt; MINSIZE) {
            set_inuse_bit_at_offset(victim, size);
            if (av != &amp;main_arena) set_non_main_arena(victim);
        }

        /* Split */
        // 如果够，尽管分割
        else {
            // 计算剩余的chunk的偏移
            remainder = chunk_at_offset(victim, nb);

            /* We cannot assume the unsorted list is empty and therefore
               have to perform a complete insert here.  */
            // 将剩余的chunk插入到unsorted bin中
            bck = unsorted_chunks(av);
            fwd = bck-&gt;fd;
            if (__glibc_unlikely(fwd-&gt;bk != bck)) {
                errstr = &quot;malloc(): corrupted unsorted chunks 2&quot;;
                goto errout;
            }
            remainder-&gt;bk = bck;
            remainder-&gt;fd = fwd;
            bck-&gt;fd       = remainder;
            fwd-&gt;bk       = remainder;

            /* advertise as last remainder */
            // 如果在small bin范围内，就将其标记为remainder
            if (in_smallbin_range(nb)) av-&gt;last_remainder = remainder;
            if (!in_smallbin_range(remainder_size)) {
                remainder-&gt;fd_nextsize = NULL;
                remainder-&gt;bk_nextsize = NULL;
            }
            // 设置victim的使用状态
            set_head(victim,
                     nb | PREV_INUSE |
                         (av != &amp;main_arena ? NON_MAIN_ARENA : 0));
            // 设置remainder的使用状态，这里是为什么呢？
            set_head(remainder, remainder_size | PREV_INUSE);
            // 设置remainder的大小
            set_foot(remainder, remainder_size);
        }
        // 检查
        check_malloced_chunk(av, victim, nb);
        // chunk状态转换到mem状态
        void *p = chunk2mem(victim);
        // 如果设置了perturb_type, 则将获取到的chunk初始化为 perturb_type ^ 0xff
        alloc_perturb(p, bytes);
        return p;
    }
}
</pre></div>
</div>
</div>
<div class="section" id="top-chunk">
<h5>使用top chunk<a class="headerlink" href="#top-chunk" title="永久链接至标题">¶</a></h5>
<p>如果所有的bin中的chunk都没有办法直接满足要求（即不合并），或者说都没有空闲的chunk。那么我们就只能使用top chunk了。</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>use_top:
    /*
       If large enough, split off the chunk bordering the end of memory
       (held in av-&gt;top). Note that this is in accord with the best-fit
       search rule.  In effect, av-&gt;top is treated as larger (and thus
       less well fitting) than any other available chunk since it can
       be extended to be as large as necessary (up to system
       limitations).

       We require that av-&gt;top always exists (i.e., has size &gt;=
       MINSIZE) after initialization, so if it would otherwise be
       exhausted by current request, it is replenished. (The main
       reason for ensuring it exists is that we may need MINSIZE space
       to put in fenceposts in sysmalloc.)
     */
    // 获取当前的top chunk，并计算其对应的大小
    victim = av-&gt;top;
    size   = chunksize(victim);
    // 如果在分割之后，其大小仍然满足chunk的最小大小，那么就可以直接进行分割。
    if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE)) {
        remainder_size = size - nb;
        remainder      = chunk_at_offset(victim, nb);
        av-&gt;top        = remainder;
        set_head(victim, nb | PREV_INUSE |
                             (av != &amp;main_arena ? NON_MAIN_ARENA : 0));
        set_head(remainder, remainder_size | PREV_INUSE);

        check_malloced_chunk(av, victim, nb);
        void *p = chunk2mem(victim);
        alloc_perturb(p, bytes);
        return p;
    }
    // 否则，判断是否有fast chunk
    /* When we are using atomic ops to free fast chunks we can get
       here for all block sizes.  */
    else if (have_fastchunks(av)) {
        // 先执行一次fast bin的合并
        malloc_consolidate(av);
        /* restore original bin index */
        // 判断需要的chunk是在small bin范围内还是large bin范围内
        // 并计算对应的索引
        // 等待下次再看看是否可以
        if (in_smallbin_range(nb))
            idx = smallbin_index(nb);
        else
            idx = largebin_index(nb);
    }

    /*
       Otherwise, relay to handle system-dependent cases
     */
    // 否则的话，我们就只能从系统中再次申请一点内存了。
    else {
        void *p = sysmalloc(nb, av);
        if (p != NULL) alloc_perturb(p, bytes);
        return p;
    }
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="sysmalloc">
<h3>sysmalloc<a class="headerlink" href="#sysmalloc" title="永久链接至标题">¶</a></h3>
<p>有时间的时候再分析。</p>
</div>
<div class="section" id="malloc-consolidate">
<h3>malloc_consolidate<a class="headerlink" href="#malloc-consolidate" title="永久链接至标题">¶</a></h3>
<p>有时间的时候再分析。</p>
</div>
</div>
<div class="section" id="id12">
<h2>释放内存块<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h2>
<div class="section" id="libc-free">
<h3>__libc_free<a class="headerlink" href="#libc-free" title="永久链接至标题">¶</a></h3>
<p>类似于malloc，free函数也有一层封装，命名格式与malloc基本类似。代码如下</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>void __libc_free(void *mem) {
    mstate    ar_ptr;
    mchunkptr p; /* chunk corresponding to mem */
    // 判断是否有钩子函数
    void (*hook)(void *, const void *) = atomic_forced_read(__free_hook);
    if (__builtin_expect(hook != NULL, 0)) {
        (*hook)(mem, RETURN_ADDRESS(0));
        return;
    }
    // free NULL没有作用
    if (mem == 0) /* free(0) has no effect */
        return;
    // 将mem转换为chunk状态
    p = mem2chunk(mem);
    // 如果该块内存是mmap得到的
    if (chunk_is_mmapped(p)) /* release mmapped memory. */
    {
        /* See if the dynamic brk/mmap threshold needs adjusting.
       Dumped fake mmapped chunks do not affect the threshold.  */
        if (!mp_.no_dyn_threshold &amp;&amp; chunksize_nomask(p) &gt; mp_.mmap_threshold &amp;&amp;
            chunksize_nomask(p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX &amp;&amp;
            !DUMPED_MAIN_ARENA_CHUNK(p)) {
            mp_.mmap_threshold = chunksize(p);
            mp_.trim_threshold = 2 * mp_.mmap_threshold;
            LIBC_PROBE(memory_mallopt_free_dyn_thresholds, 2,
                       mp_.mmap_threshold, mp_.trim_threshold);
        }
        munmap_chunk(p);
        return;
    }
    // 根据chunk获得分配区的指针
    ar_ptr = arena_for_chunk(p);
    // 执行释放
    _int_free(ar_ptr, p, 0);
}
</pre></div>
</div>
</div>
<div class="section" id="int-free">
<h3>_int_free<a class="headerlink" href="#int-free" title="永久链接至标题">¶</a></h3>
<div class="section" id="id13">
<h4>概述<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h4>
</div>
<div class="section" id="id14">
<h4>初始化<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h4>
<p>进行函数后，立马定义了一系列的变量，并且得到了用户想要释放的chunk的大小</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="n">static</span> <span class="n">void</span> <span class="n">_int_free</span><span class="p">(</span><span class="n">mstate</span> <span class="n">av</span><span class="p">,</span> <span class="n">mchunkptr</span> <span class="n">p</span><span class="p">,</span> <span class="nb">int</span> <span class="n">have_lock</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">INTERNAL_SIZE_T</span> <span class="n">size</span><span class="p">;</span>      <span class="o">/*</span> <span class="n">its</span> <span class="n">size</span> <span class="o">*/</span>
    <span class="n">mfastbinptr</span> <span class="o">*</span>   <span class="n">fb</span><span class="p">;</span>        <span class="o">/*</span> <span class="n">associated</span> <span class="n">fastbin</span> <span class="o">*/</span>
    <span class="n">mchunkptr</span>       <span class="n">nextchunk</span><span class="p">;</span> <span class="o">/*</span> <span class="nb">next</span> <span class="n">contiguous</span> <span class="n">chunk</span> <span class="o">*/</span>
    <span class="n">INTERNAL_SIZE_T</span> <span class="n">nextsize</span><span class="p">;</span>  <span class="o">/*</span> <span class="n">its</span> <span class="n">size</span> <span class="o">*/</span>
    <span class="nb">int</span>             <span class="n">nextinuse</span><span class="p">;</span> <span class="o">/*</span> <span class="n">true</span> <span class="k">if</span> <span class="n">nextchunk</span> <span class="ow">is</span> <span class="n">used</span> <span class="o">*/</span>
    <span class="n">INTERNAL_SIZE_T</span> <span class="n">prevsize</span><span class="p">;</span>  <span class="o">/*</span> <span class="n">size</span> <span class="n">of</span> <span class="n">previous</span> <span class="n">contiguous</span> <span class="n">chunk</span> <span class="o">*/</span>
    <span class="n">mchunkptr</span>       <span class="n">bck</span><span class="p">;</span>       <span class="o">/*</span> <span class="n">misc</span> <span class="n">temp</span> <span class="k">for</span> <span class="n">linking</span> <span class="o">*/</span>
    <span class="n">mchunkptr</span>       <span class="n">fwd</span><span class="p">;</span>       <span class="o">/*</span> <span class="n">misc</span> <span class="n">temp</span> <span class="k">for</span> <span class="n">linking</span> <span class="o">*/</span>

    <span class="n">const</span> <span class="n">char</span> <span class="o">*</span><span class="n">errstr</span> <span class="o">=</span> <span class="n">NULL</span><span class="p">;</span>
    <span class="nb">int</span>         <span class="n">locked</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">size</span> <span class="o">=</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="id15">
<h4>简单的检查<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h4>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/* Little security check which won&#39;t hurt performance: the
   allocator never wrapps around at the end of the address space.
   Therefore we can exclude some size values which might appear
   here by accident or by &quot;design&quot; from some intruder.  */
// 指针不能指向非法的地址
// 指针必须得对齐，这个对齐得仔细想想
if (__builtin_expect((uintptr_t) p &gt; (uintptr_t) -size, 0) ||
    __builtin_expect(misaligned_chunk(p), 0)) {
    errstr = &quot;free(): invalid pointer&quot;;
errout:
    if (!have_lock &amp;&amp; locked) __libc_lock_unlock(av-&gt;mutex);
    malloc_printerr(check_action, errstr, chunk2mem(p), av);
    return;
}
/* We know that each chunk is at least MINSIZE bytes in size or a
   multiple of MALLOC_ALIGNMENT.  */
// 大小没有最小的chunk大，或者说，大小不是MALLOC_ALIGNMENT的整数倍
if (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size))) {
    errstr = &quot;free(): invalid size&quot;;
    goto errout;
}
// 检查该chunk是否处于使用状态，如果
check_inuse_chunk(av, p);
</pre></div>
</div>
</div>
<div class="section" id="id16">
<h4>fast bin<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h4>
<p>如果上述检查都合格的话，判断当前的bin是不是在fast bin范围内，在的话，就插入到fastbin中</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>    /*
      If eligible, place chunk on a fastbin so it can be found
      and used quickly in malloc.
    */

    if ((unsigned long) (size) &lt;= (unsigned long) (get_max_fast())

##if TRIM_FASTBINS
        /*
      If TRIM_FASTBINS set, don&#39;t place chunks
      bordering top into fastbins
        */
       // 如果当前chunk是fast chunk，并且下一个chunk是top chunk，则不能插入
        &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)
##endif
            ) {
        // 下一个chunk的大小不能小于两倍的SIZE_SZ,并且
        // 下一个chunk的大小不能大于系统可提供的内存
        // 如果出现这样的情况，就报错。
        if (__builtin_expect(
                chunksize_nomask(chunk_at_offset(p, size)) &lt;= 2 * SIZE_SZ, 0) ||
            __builtin_expect(
                chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem, 0)) {
            /* We might not have a lock at this point and concurrent
               modifications
               of system_mem might have let to a false positive.  Redo the test
               after getting the lock.  */
            if (have_lock || ({
                    assert(locked == 0);
                    __libc_lock_lock(av-&gt;mutex);
                    locked = 1;
                    chunksize_nomask(chunk_at_offset(p, size)) &lt;= 2 * SIZE_SZ ||
                        chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem;
                })) {
                errstr = &quot;free(): invalid next size (fast)&quot;;
                goto errout;
            }
            if (!have_lock) {
                __libc_lock_unlock(av-&gt;mutex);
                locked = 0;
            }
        }
        // 将chunk的mem部分全部设置为perturb_byte
        free_perturb(chunk2mem(p), size - 2 * SIZE_SZ);
        // 设置fast chunk的标记位
        set_fastchunks(av);
        // 根据大小获取fast bin的索引
        unsigned int idx = fastbin_index(size);
        // 获取对应fastbin的头指针，被初始化后为NULL。
        fb               = &amp;fastbin(av, idx);

        /* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */
        // 使用原子操作将P插入到链表中
        mchunkptr    old     = *fb, old2;
        unsigned int old_idx = ~0u;
        do {
            /* Check that the top of the bin is not the record we are going to
               add
               (i.e., double free).  */
            // so we can not double free one fastbin chunk
            // 防止对fast bin double free
            if (__builtin_expect(old == p, 0)) {
                errstr = &quot;double free or corruption (fasttop)&quot;;
                goto errout;
            }
            /* Check that size of fastbin chunk at the top is the same as
               size of the chunk that we are adding.  We can dereference OLD
               only if we have the lock, otherwise it might have already been
               deallocated.  See use of OLD_IDX below for the actual check.  */
            if (have_lock &amp;&amp; old != NULL)
                old_idx = fastbin_index(chunksize(old));
            p-&gt;fd = old2 = old;
        } while ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) !=
                 old2);
        // 确保fast bin的加入前与加入后相同
        if (have_lock &amp;&amp; old != NULL &amp;&amp; __builtin_expect(old_idx != idx, 0)) {
            errstr = &quot;invalid fastbin entry (free)&quot;;
            goto errout;
        }
    }
</pre></div>
</div>
</div>
<div class="section" id="mmapchunk">
<h4>合并非mmap的空闲chunk<a class="headerlink" href="#mmapchunk" title="永久链接至标题">¶</a></h4>
<p>首先，我们先说一下为什么会合并chunk，这是为了避免heap中有太多的零零碎碎的内存块，合并之后可以用来应对更大的内存块请求。</p>
<p>合并的主要顺序为</p>
<ul class="simple">
<li>先考虑低地址空闲块</li>
<li>后考虑高地址空闲块</li>
</ul>
<p><strong>合并后的chunk指向所有合并的chunk的低地址。</strong></p>
<p>在没有锁的情况下，先获得锁。</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/*
  Consolidate other non-mmapped chunks as they arrive.
*/

else if (!chunk_is_mmapped(p)) {
    if (!have_lock) {
        __libc_lock_lock(av-&gt;mutex);
        locked = 1;
    }
</pre></div>
</div>
<div class="section" id="id17">
<h5>轻量级的检测<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h5>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/* Lightweight tests: check whether the block is already the
   top block.  */
// 当前free的chunk不能是top chunk
if (__glibc_unlikely(p == av-&gt;top)) {
    errstr = &quot;double free or corruption (top)&quot;;
    goto errout;
}
// 当前free的chunk的下一个chunk不能超过arena的边界
/* Or whether the next chunk is beyond the boundaries of the arena.  */
if (__builtin_expect(contiguous(av) &amp;&amp;
                         (char *) nextchunk &gt;=
                             ((char *) av-&gt;top + chunksize(av-&gt;top)),
                     0)) {
    errstr = &quot;double free or corruption (out)&quot;;
    goto errout;
}
// 当前要free的chunk的使用标记没有被标记，double free
/* Or whether the block is actually not marked used.  */
if (__glibc_unlikely(!prev_inuse(nextchunk))) {
    errstr = &quot;double free or corruption (!prev)&quot;;
    goto errout;
}
// 下一个chunk的大小
nextsize = chunksize(nextchunk);
// next chunk size valid check
// 判断下一个chunk的大小是否不大于2*SIZE_SZ，或者
// nextsize是否大于系统可提供的内存
if (__builtin_expect(chunksize_nomask(nextchunk) &lt;= 2 * SIZE_SZ, 0) ||
    __builtin_expect(nextsize &gt;= av-&gt;system_mem, 0)) {
    errstr = &quot;free(): invalid next size (normal)&quot;;
    goto errout;
}
</pre></div>
</div>
</div>
<div class="section" id="id18">
<h5>释放填充<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h5>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">//</span><span class="n">将</span> <span class="n">指针的mem部分全部设置为perturb_byte</span>
<span class="n">free_perturb</span><span class="p">(</span><span class="n">chunk2mem</span><span class="p">(</span><span class="n">p</span><span class="p">),</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="chunk">
<h5>后向合并-合并低地址chunk<a class="headerlink" href="#chunk" title="永久链接至标题">¶</a></h5>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/* consolidate backward */
if (!prev_inuse(p)) {
    prevsize = prev_size(p);
    size += prevsize;
    p = chunk_at_offset(p, -((long) prevsize));
    unlink(av, p, bck, fwd);
}
</pre></div>
</div>
</div>
<div class="section" id="top-chunk-chunk">
<h5>下一块不是top chunk-前向合并-合并高地址chunk<a class="headerlink" href="#top-chunk-chunk" title="永久链接至标题">¶</a></h5>
<p>需要注意的是，如果下一块不是top chunk后，合并后的chunk会被放入到unsorted bin中。</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>// 如果下一个chunk不是top chunk
if (nextchunk != av-&gt;top) {
    /* get and clear inuse bit */
    // 获取下一个chunk的使用状态
    nextinuse = inuse_bit_at_offset(nextchunk, nextsize);
    // 如果不在使用，合并，否则清空当前chunk的使用状态。
    /* consolidate forward */
    if (!nextinuse) {
        unlink(av, nextchunk, bck, fwd);
        size += nextsize;
    } else
        clear_inuse_bit_at_offset(nextchunk, 0);

    /*
  Place the chunk in unsorted chunk list. Chunks are
  not placed into regular bins until after they have
  been given one chance to be used in malloc.
    */
    // 把chunk放在unsorted chunk链表的尾部
    bck = unsorted_chunks(av);
    fwd = bck-&gt;fd;
    // 简单的检查
    if (__glibc_unlikely(fwd-&gt;bk != bck)) {
        errstr = &quot;free(): corrupted unsorted chunks&quot;;
        goto errout;
    }
    p-&gt;fd = fwd;
    p-&gt;bk = bck;
    if (!in_smallbin_range(size)) {
        p-&gt;fd_nextsize = NULL;
        p-&gt;bk_nextsize = NULL;
    }
    bck-&gt;fd = p;
    fwd-&gt;bk = p;

    set_head(p, size | PREV_INUSE);
    set_foot(p, size);

    check_free_chunk(av, p);
}
</pre></div>
</div>
</div>
<div class="section" id="top-chunk-top-chunk">
<h5>下一块是top chunk-合并到top chunk<a class="headerlink" href="#top-chunk-top-chunk" title="永久链接至标题">¶</a></h5>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/*
  If the chunk borders the current high end of memory,
  consolidate into top
*/
// 如果要释放的chunk的下一个chunk是top chunk，那就合并到 top chunk
else {
    size += nextsize;
    set_head(p, size | PREV_INUSE);
    av-&gt;top = p;
    check_chunk(av, p);
}
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h5>向系统返还内存<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h5>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>        /*
          If freeing a large space, consolidate possibly-surrounding
          chunks. Then, if the total unused topmost memory exceeds trim
          threshold, ask malloc_trim to reduce top.

          Unless max_fast is 0, we don&#39;t know if there are fastbins
          bordering top, so we cannot tell for sure whether threshold
          has been reached unless fastbins are consolidated.  But we
          don&#39;t want to consolidate on each free.  As a compromise,
          consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD
          is reached.
        */
         // 如果合并后的chunk的大小大于FASTBIN_CONSOLIDATION_THRESHOLD
         // 那就向系统返还内存
        if ((unsigned long) (size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) {
            // 如果有fast chunk 就进行合并
            if (have_fastchunks(av)) malloc_consolidate(av);
            // 主分配区
            if (av == &amp;main_arena) {
##ifndef MORECORE_CANNOT_TRIM
                // top chunk 大于当前的收缩阙值
                if ((unsigned long) (chunksize(av-&gt;top)) &gt;=
                    (unsigned long) (mp_.trim_threshold))
                    systrim(mp_.top_pad, av);
##endif      // 非主分配区，则直接收缩heap
            } else {
                /* Always try heap_trim(), even if the top chunk is not
                   large, because the corresponding heap might go away.  */
                heap_info *heap = heap_for_ptr(top(av));

                assert(heap-&gt;ar_ptr == av);
                heap_trim(heap, mp_.top_pad);
            }
        }

        if (!have_lock) {
            assert(locked);
            __libc_lock_unlock(av-&gt;mutex);
        }
</pre></div>
</div>
</div>
</div>
<div class="section" id="id20">
<h4>释放mmap的chunk<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h4>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="o">//</span>  <span class="n">If</span> <span class="n">the</span> <span class="n">chunk</span> <span class="n">was</span> <span class="n">allocated</span> <span class="n">via</span> <span class="n">mmap</span><span class="p">,</span> <span class="n">release</span> <span class="n">via</span> <span class="n">munmap</span><span class="p">()</span><span class="o">.</span>
    <span class="n">munmap_chunk</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="unlink">
<h3>unlink<a class="headerlink" href="#unlink" title="永久链接至标题">¶</a></h3>
<p>unlink函数主要是将chunk P从bin中取出来，如下</p>
<div class="code c highlight-default"><div class="highlight"><pre><span></span>/* Take a chunk off a bin list */
##define unlink(AV, P, BK, FD) {                                            \
    FD = P-&gt;fd;                                                                      \
    BK = P-&gt;bk;                                                                      \
    if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                      \
      malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV);  \
    else {                                                                      \
        FD-&gt;bk = BK;                                                              \
        BK-&gt;fd = FD;                                                              \
        if (!in_smallbin_range (chunksize_nomask (P))                              \
            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) {                      \
            if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0)              \
                || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0))    \
              malloc_printerr (check_action,                                      \
                               &quot;corrupted double-linked list (not small)&quot;,    \
                               P, AV);                                              \
            if (FD-&gt;fd_nextsize == NULL) {                                      \
                if (P-&gt;fd_nextsize == P)                                      \
                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                      \
                else {                                                              \
                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                              \
                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                              \
                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                              \
                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                              \
                  }                                                              \
              } else {                                                              \
                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                      \
                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                      \
              }                                                                      \
          }                                                                      \
      }                                                                              \
}
</pre></div>
</div>
<p>可以看到首先是分别获取P的forward chunk和backward chunk。</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">FD</span> <span class="o">=</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>                                                                      \
<span class="n">BK</span> <span class="o">=</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">bk</span><span class="p">;</span>                                                                      \
</pre></div>
</div>
<p>接下来有这样的一个判断</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">__builtin_expect</span> <span class="p">(</span><span class="n">FD</span><span class="o">-&gt;</span><span class="n">bk</span> <span class="o">!=</span> <span class="n">P</span> <span class="o">||</span> <span class="n">BK</span><span class="o">-&gt;</span><span class="n">fd</span> <span class="o">!=</span> <span class="n">P</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>                      \
  <span class="n">malloc_printerr</span> <span class="p">(</span><span class="n">check_action</span><span class="p">,</span> <span class="s2">&quot;corrupted double-linked list&quot;</span><span class="p">,</span> <span class="n">P</span><span class="p">,</span> <span class="n">AV</span><span class="p">);</span>  \
</pre></div>
</div>
<p>看起来似乎很正常，P的forward chunk的bk很自然是P，同样P的backward chunk的fd也很自然是P。然而，这里真正的目的在于进行双向链表的冲突检测。</p>
<p>考虑加入没有的情况，如果我们将该chunk
的fd为某个got表项-12(32位)的地址，同时修改bk为shellcode代码，这样当执行完下面的代码后，该got表项的地址其实就是shellcode的地址。如果我们调用了该got表项对应的函数，那么实际上执行的就是shellcode。所以这里的检查是必要的。</p>
<p>然后就是直接修改相应的指针，去掉P。</p>
<p>接下来判断chunk P是否属于large chunk，如果属于就需要进行进一步的处理。</p>
<p><strong>注意：堆的第一个chunk的话所记录的prev_inuse位默认为1。</strong></p>
<ol class="arabic simple">
<li><strong>给出图片说明</strong></li>
<li><strong>说明unlink的判断</strong></li>
</ol>
</div>
<div class="section" id="systrim">
<h3>systrim<a class="headerlink" href="#systrim" title="永久链接至标题">¶</a></h3>
</div>
<div class="section" id="heap-trim">
<h3>heap_trim<a class="headerlink" href="#heap-trim" title="永久链接至标题">¶</a></h3>
</div>
<div class="section" id="munmap-chunk">
<h3>munmap_chunk<a class="headerlink" href="#munmap-chunk" title="永久链接至标题">¶</a></h3>
</div>
</div>
<div class="section" id="id21">
<h2>删除堆<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h2>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="heapoverflow_basic.html" class="btn btn-neutral float-right" title="堆溢出" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="heap_structure.html" class="btn btn-neutral" title="堆相关数据结构" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2017, CTF Wiki.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../_static/translations.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>