<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>堆相关数据结构 &#8212; CTF Wiki  documentation</title>
    <link rel="stylesheet" href="../../_static/bootstrap-sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/css/overflow.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../_static/js/jquery-1.11.0.min.js"></script>
    <script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-3.3.7/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="深入理解堆的实现" href="heap_implementation_details.html" />
    <link rel="prev" title="基本堆介绍" href="heap_basic_intro.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">

  </head>
  <body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          CTF Wiki</a>
        <span class="navbar-text navbar-version pull-left"><b></b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Chapters <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption"><span class="caption-text">CTF 介绍</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/history.html">CTF 竞赛的历史</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../introduction/history.html#id1">CTF 的起源</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../introduction/history.html#id2">早期 CTF 竞赛</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../introduction/history.html#id3">「现代」CTF 竞赛</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/mode.html">CTF 竞赛模式简介</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../introduction/mode.html#jeopardy">解题模式 - Jeopardy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../introduction/mode.html#belluminar">战争分享模式 - Belluminar</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../introduction/mode.html#attack-defense">攻防模式 - Attack &amp; Defense</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/content.html">CTF 竞赛内容</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../introduction/content.html#id1">全国大学生信息安全竞赛 - 竞赛内容</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/experience.html">线下攻防经验小结</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../introduction/experience.html#gamebox">关注 Gamebox 状态</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../introduction/experience.html#id2">分清区段与端口</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../introduction/experience.html#patch">服务 patch 与防御</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../introduction/experience.html#id3">构造脚本框架快速展开攻击</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../introduction/experience.html#id4">比赛的一些策略</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/cgc.html">CGC 网络超级挑战赛</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../introduction/cgc.html#id1">性能评价指标</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../introduction/cgc.html#id2">明确核心任务</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../introduction/cgc.html#id3">分析方法</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../introduction/cgc.html#id4">CGC 经验总结</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../introduction/resources.html">学习资源</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../introduction/resources.html#id2">在线学习</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../introduction/resources.html#id3">信息资讯</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../introduction/resources.html#id4">论坛</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../introduction/resources.html#ctf-oj">CTF OJ</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../introduction/resources.html#ctf-writeup">CTF Writeup 集合</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Misc</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../misc/about.html">杂项简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/recon.html">信息搜集技术</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../misc/recon.html#id2">网络信息搜集技巧</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/recon.html#id3">基本搜索技巧</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/recon.html#id4">地图和街景搜索</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/encode/index.html">编码分析</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../misc/encode/communication.html">通信领域常用的编码</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/encode/computer.html">计算机相关的编码</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/encode/modern.html">现实世界中常用的编码</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/prefix.html">取证隐写</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../misc/prefix.html#id2">前置技能</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/prefix.html#python">python操作二进制数据</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/prefix.html#id3">常用工具</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/picture/index.html">图片分析</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../misc/picture/about.html">Image Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/picture/png.html">PNG</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/picture/jpg.html">JPG</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/picture/gif.html">GIF</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/archive/index.html">压缩包分析</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../misc/archive/zip.html">Zip 格式</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/archive/rar.html">Rar 格式</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/audio/index.html">音频分析</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../misc/audio/index.html#id2">常见手段</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/audio/index.html#mp3">MP3 隐写</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/audio/index.html#id5">波形</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/audio/index.html#id8">频谱</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/audio/index.html#lsb">LSB音频隐写</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/audio/index.html#id13">延伸</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/disk_memory/index.html">磁盘 / 内存分析</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../misc/disk_memory/index.html#id2">常用工具</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/disk_memory/index.html#id3">磁盘</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/disk_memory/index.html#vmdk">VMDK</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/disk_memory/index.html#id4">内存</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/disk_memory/index.html#id5">题目</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/disk_memory/index.html#id6">参考</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/cap.html">流量分析</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../misc/cap.html#id2">基本工具</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/cap.html#id4">常见题型</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../misc/cap.html#id5">题目</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../misc/others.html">其他</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../misc/others.html#shellcode">shellcode</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Crypto</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/introduction.html">密码学简介</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/classical/index.html">古典密码</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../crypto/classical/monoalphabetic.html">单表代换密码</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../crypto/classical/polyalphabetic.html">多表代换加密</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../crypto/classical/others.html">其他类型</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../crypto/classical/summary.html">总结</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/symmetric/index.html">对称加密</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../crypto/symmetric/des.html">DES</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../crypto/symmetric/aes.html">AES</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../crypto/symmetric/block_cipher.html">分组模式</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/asymmetric/index.html">非对称密码</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../crypto/asymmetric/rsa/rsa_index.html">RSA</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../crypto/asymmetric/knapsack/knapsack_intro.html">背包加密</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../crypto/asymmetric/discrete_log/discrete_log_intro.html">离散对数相关</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/hash/index.html">哈希函数</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../crypto/hash/md5.html">MD5</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../crypto/hash/sha1.html">SHA1</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../crypto/hash/attack.html">Hash Attack</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/signature/index.html">数字签名</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../crypto/signature/rsa.html">RSA数字签名</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../crypto/signature/elgamal.html">ElGamal</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../crypto/signature/dsa.html">DSA</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../crypto/others/others.html">证书格式</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../crypto/others/others.html#der">DER</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../crypto/others/others.html#pem">PEM</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../crypto/others/others.html#id2">格式转换</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Web</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../web/index.html">WEB 简介</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../web/index.html#sql">SQL 注入</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/index.html#xss">XSS 跨站脚本攻击</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/index.html#id1">命令执行</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/index.html#id2">文件包含</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/index.html#csrf">CSRF 跨站请求伪造</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/index.html#ssrf">SSRF 服务器端请求伪造</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/index.html#id3">文件上传</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/index.html#id4">点击劫持</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/index.html#vps">VPS 虚拟专用服务器</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/index.html#id5">条件竞争</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/index.html#xxe">XXE</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/index.html#xsch">XSCH</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/index.html#id6">越权（功能级访问缺失）</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/index.html#id7">敏感信息泄露</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/index.html#id8">错误的安全配置</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/index.html#waf">WAF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/index.html#ids">IDS</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/index.html#ips">IPS</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../web/sqli.html">SQL 注入</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../web/sqli.html#id1">基本概念</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/sqli.html#id2">常用工具</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/sqli.html#id3">注入常见参数</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/sqli.html#id4">语法参考与小技巧</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/sqli.html#id8">后台万能密码</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/sqli.html#id9">注入语句备忘</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/sqli.html#id19">参考资料</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../web/xss.html">XSS 跨站脚本攻击</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../web/xss.html#id1">XSS 简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/xss.html#id4">XSS 利用方式</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../web/csrf.html">CSRF 跨站请求伪造</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../web/csrf.html#id1">CSRF 简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/csrf.html#id2">CSRF 类型</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/csrf.html#id3">CSRF 的防御</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../web/ssrf.html">SSRF 服务端请求伪造</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../web/ssrf.html#id1">SSRF 简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/ssrf.html#id2">SSRF 漏洞出现的场景</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/ssrf.html#id3">常用的后端实现</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/ssrf.html#id4">阻碍 SSRF 漏洞利用的场景</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/ssrf.html#id5">利用 SSRF 进行端口扫描</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/ssrf.html#id7">协议利用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/ssrf.html#id8">参考资料</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../web/php.html">PHP 代码审计</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../web/php.html#id1">文件包含</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/php.html#id4">文件上传</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/php.html#id6">变量覆盖</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/php.html#id8">命令执行</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/php.html#id14">PHP 特性</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../web/php.html#id19">寻找源代码备份</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Reverse</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../reverse/index.html">Reverse Engineering</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../reverse/introduction.html">软件逆向工程简介</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reverse/x86assembly.html">施工中</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reverse/protection.html">施工中</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reverse/analysis/index.html">逆向分析核心技术</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../reverse/resources.html">施工中</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Pwn</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../stackoverflow/index.html">栈溢出</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../stackoverflow/stack_intro.html">栈介绍</a></li>
<li class="toctree-l2"><a class="reference internal" href="../stackoverflow/stackoverflow_basic.html">栈溢出原理</a></li>
<li class="toctree-l2"><a class="reference internal" href="../stackoverflow/basic_rop.html">基本ROP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../stackoverflow/others.html">花式栈溢出技巧</a></li>
<li class="toctree-l2"><a class="reference internal" href="../stackoverflow/medium_rop.html">中级ROP</a></li>
<li class="toctree-l2"><a class="reference internal" href="../stackoverflow/advanced_rop.html">高级ROP</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../fmtstr/index.html">格式化字符串漏洞</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../fmtstr/fmtstr_intro.html">格式化字符串漏洞原理介绍</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fmtstr/fmtstr_exploit.html">格式化字符串漏洞利用</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fmtstr/fmtstr_example.html">格式化字符串漏洞例子</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fmtstr/fmtstr_detect.html">格式化字符串漏洞检测</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">堆利用</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="heap_basic_intro.html">基本堆介绍</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">堆相关数据结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="heap_implementation_details.html">深入理解堆的实现</a></li>
<li class="toctree-l2"><a class="reference internal" href="heapoverflow_basic.html">堆溢出</a></li>
<li class="toctree-l2"><a class="reference internal" href="off_by_one.html">堆中的off-by-one</a></li>
<li class="toctree-l2"><a class="reference internal" href="chunk_extend_shrink.html">chunk extend/shrink</a></li>
<li class="toctree-l2"><a class="reference internal" href="unlink.html">unlink</a></li>
<li class="toctree-l2"><a class="reference internal" href="use_after_free.html">Use After Free</a></li>
<li class="toctree-l2"><a class="reference internal" href="fastbin_attack.html">fastbin attack</a></li>
<li class="toctree-l2"><a class="reference internal" href="unsorted_bin_attack.html">Unsorted Bin Attack</a></li>
<li class="toctree-l2"><a class="reference internal" href="house_of_lore.html">House of Lore</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Executable</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../executable/elf/index.html">ELF文件</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../executable/elf/elf_structure.html">ELF文件基本结构</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../executable/elf/program_loading.html">程序加载</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../executable/elf/program_linking.html">程序链接</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../executable/elf/running_overview.html">程序执行流程</a></li>
</ul>
</li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Sections <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"><ul>
<li><a class="reference internal" href="#">堆相关数据结构</a><ul>
<li><a class="reference internal" href="#overview">Overview？？？？</a></li>
<li><a class="reference internal" href="#id2">宏观结构</a><ul>
<li><a class="reference internal" href="#arena">arena</a><ul>
<li><a class="reference internal" href="#id3">arena 数量</a></li>
<li><a class="reference internal" href="#id4">arena 分配规则</a></li>
<li><a class="reference internal" href="#id5">区别</a></li>
</ul>
</li>
<li><a class="reference internal" href="#heap-info">heap_info</a></li>
<li><a class="reference internal" href="#malloc-state">malloc_state</a></li>
<li><a class="reference internal" href="#malloc-par">malloc_par</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id6">微观结构</a><ul>
<li><a class="reference internal" href="#malloc-chunk">malloc_chunk</a><ul>
<li><a class="reference internal" href="#id7">概述</a></li>
<li><a class="reference internal" href="#chunk">chunk相关宏</a></li>
</ul>
</li>
<li><a class="reference internal" href="#bin">bin</a><ul>
<li><a class="reference internal" href="#id8">概述</a></li>
<li><a class="reference internal" href="#fast-bin">fast bin</a></li>
<li><a class="reference internal" href="#small-bin">small bin</a></li>
<li><a class="reference internal" href="#large-bin">large bin</a></li>
<li><a class="reference internal" href="#unsorted-bin">unsorted bin</a></li>
<li><a class="reference internal" href="#common-macro">common macro</a></li>
</ul>
</li>
<li><a class="reference internal" href="#top-chunk">top chunk</a></li>
<li><a class="reference internal" href="#last-remainder">last remainder</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</ul>
</li>
              
            
            
              
                
  <li>
    <a href="heap_basic_intro.html" title="Previous Chapter: 基本堆介绍"><span class="glyphicon glyphicon-chevron-left visible-sm"></span><span class="hidden-sm hidden-tablet">&laquo; 基本堆介绍</span>
    </a>
  </li>
  <li>
    <a href="heap_implementation_details.html" title="Next Chapter: 深入理解堆的实现"><span class="glyphicon glyphicon-chevron-right visible-sm"></span><span class="hidden-sm hidden-tablet">深入理解堆的实现 &raquo;</span>
    </a>
  </li>
              
            
            
            
            
              <li class="hidden-sm">
<div id="sourcelink">
  <a href="../../_sources/pwn/heap/heap_structure.rst.txt"
     rel="nofollow">Source</a>
</div></li>
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="col-md-12 content">
      
  <div class="section" id="id1">
<h1>堆相关数据结构<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>既然堆的操作本身这么复杂，那么在glibc内部必然也有相应的精妙设计的数据结构来管理它。与堆相应的数据结构主要分为</p>
<ul class="simple">
<li>宏观结构，主要说明堆的宏观信息，可以通过这些数据结构来得到堆的一些基本信息。</li>
<li>微观结构，主要用于表示在宏观结构下更加细致的结构，一般堆的分配与回收主要是与这些结构进行交流。</li>
</ul>
<div class="section" id="overview">
<h2>Overview？？？？<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h2>
<p><strong>这里给一个宏观的图片。</strong></p>
</div>
<div class="section" id="id2">
<h2>宏观结构<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<div class="section" id="arena">
<h3>arena<a class="headerlink" href="#arena" title="Permalink to this headline">¶</a></h3>
<p>正如我们之前所说的，无论是主线程还是新创建的线程来说在第一次申请内存时，都会有自己独立的arena，那么会不会每个线程都有自己的arena呢？下面我们就具体介绍。</p>
<div class="section" id="id3">
<h4>arena 数量<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h4>
<p>不是每一个线程都会有对应的arena，这是因为每个系统的核数是有限的，当线程数大于核数的二倍时，就必然有线程处于等待状态。所以没有必要为每个线程分配一个arena的。具体的<a class="reference external" href="https://github.com/sploitfun/lsploits/blob/master/glibc/malloc/arena.c#L847">约束</a>如下</p>
<div class="code text highlight-default"><div class="highlight"><pre><span></span><span class="n">For</span> <span class="mi">32</span> <span class="n">bit</span> <span class="n">systems</span><span class="p">:</span>
     <span class="n">Number</span> <span class="n">of</span> <span class="n">arena</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">number</span> <span class="n">of</span> <span class="n">cores</span><span class="o">.</span>
<span class="n">For</span> <span class="mi">64</span> <span class="n">bit</span> <span class="n">systems</span><span class="p">:</span>
     <span class="n">Number</span> <span class="n">of</span> <span class="n">arena</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">number</span> <span class="n">of</span> <span class="n">cores</span><span class="o">.</span>
</pre></div>
</div>
<p>至于为什么64位系统，要那么设置，我也没有想明白。</p>
</div>
<div class="section" id="id4">
<h4>arena 分配规则<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p><strong>待补充。</strong></p>
</div>
<div class="section" id="id5">
<h4>区别<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h4>
<p>此外，与thread不同的是，main的arena header并不在申请的heap中，它是一个全局变量，在libc.so的数据段。</p>
</div>
</div>
<div class="section" id="heap-info">
<h3>heap_info<a class="headerlink" href="#heap-info" title="Permalink to this headline">¶</a></h3>
<p>该数据结构是专门为从Memory Mapping Segment处申请的内存准备的。当主线程申请较小的内存空间时，可以通过sbrk()函数扩展program break location获得（直到触及Memory Mapping
Segment），因此主线程只有一个heap，没有heap_info数据结构。</p>
<p>heap_info的主要结构如下</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="c1">##define HEAP_MIN_SIZE (32 * 1024)</span>
<span class="c1">##ifndef HEAP_MAX_SIZE</span>
<span class="c1">## ifdef DEFAULT_MMAP_THRESHOLD_MAX</span>
<span class="c1">##  define HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX)</span>
<span class="c1">## else</span>
<span class="c1">##  define HEAP_MAX_SIZE (1024 * 1024) /* must be a power of two */</span>
<span class="c1">## endif</span>
<span class="c1">##endif</span>

<span class="o">/*</span> <span class="n">HEAP_MIN_SIZE</span> <span class="ow">and</span> <span class="n">HEAP_MAX_SIZE</span> <span class="n">limit</span> <span class="n">the</span> <span class="n">size</span> <span class="n">of</span> <span class="n">mmap</span><span class="p">()</span><span class="n">ed</span> <span class="n">heaps</span>
   <span class="n">that</span> <span class="n">are</span> <span class="n">dynamically</span> <span class="n">created</span> <span class="k">for</span> <span class="n">multi</span><span class="o">-</span><span class="n">threaded</span> <span class="n">programs</span><span class="o">.</span>  <span class="n">The</span>
   <span class="n">maximum</span> <span class="n">size</span> <span class="n">must</span> <span class="n">be</span> <span class="n">a</span> <span class="n">power</span> <span class="n">of</span> <span class="n">two</span><span class="p">,</span> <span class="k">for</span> <span class="n">fast</span> <span class="n">determination</span> <span class="n">of</span>
   <span class="n">which</span> <span class="n">heap</span> <span class="n">belongs</span> <span class="n">to</span> <span class="n">a</span> <span class="n">chunk</span><span class="o">.</span>  <span class="n">It</span> <span class="n">should</span> <span class="n">be</span> <span class="n">much</span> <span class="n">larger</span> <span class="n">than</span> <span class="n">the</span>
   <span class="n">mmap</span> <span class="n">threshold</span><span class="p">,</span> <span class="n">so</span> <span class="n">that</span> <span class="n">requests</span> <span class="k">with</span> <span class="n">a</span> <span class="n">size</span> <span class="n">just</span> <span class="n">below</span> <span class="n">that</span>
   <span class="n">threshold</span> <span class="n">can</span> <span class="n">be</span> <span class="n">fulfilled</span> <span class="n">without</span> <span class="n">creating</span> <span class="n">too</span> <span class="n">many</span> <span class="n">heaps</span><span class="o">.</span>  <span class="o">*/</span>

<span class="o">/***************************************************************************/</span>

<span class="o">/*</span> <span class="n">A</span> <span class="n">heap</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">single</span> <span class="n">contiguous</span> <span class="n">memory</span> <span class="n">region</span> <span class="n">holding</span> <span class="p">(</span><span class="n">coalesceable</span><span class="p">)</span>
   <span class="n">malloc_chunks</span><span class="o">.</span>  <span class="n">It</span> <span class="ow">is</span> <span class="n">allocated</span> <span class="k">with</span> <span class="n">mmap</span><span class="p">()</span> <span class="ow">and</span> <span class="n">always</span> <span class="n">starts</span> <span class="n">at</span> <span class="n">an</span>
   <span class="n">address</span> <span class="n">aligned</span> <span class="n">to</span> <span class="n">HEAP_MAX_SIZE</span><span class="o">.</span>  <span class="o">*/</span>

<span class="n">typedef</span> <span class="n">struct</span> <span class="n">_heap_info</span>
<span class="p">{</span>
  <span class="n">mstate</span> <span class="n">ar_ptr</span><span class="p">;</span> <span class="o">/*</span> <span class="n">Arena</span> <span class="k">for</span> <span class="n">this</span> <span class="n">heap</span><span class="o">.</span> <span class="o">*/</span>
  <span class="n">struct</span> <span class="n">_heap_info</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span> <span class="o">/*</span> <span class="n">Previous</span> <span class="n">heap</span><span class="o">.</span> <span class="o">*/</span>
  <span class="n">size_t</span> <span class="n">size</span><span class="p">;</span>   <span class="o">/*</span> <span class="n">Current</span> <span class="n">size</span> <span class="ow">in</span> <span class="nb">bytes</span><span class="o">.</span> <span class="o">*/</span>
  <span class="n">size_t</span> <span class="n">mprotect_size</span><span class="p">;</span> <span class="o">/*</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span> <span class="n">that</span> <span class="n">has</span> <span class="n">been</span> <span class="n">mprotected</span>
                           <span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="o">.</span>  <span class="o">*/</span>
  <span class="o">/*</span> <span class="n">Make</span> <span class="n">sure</span> <span class="n">the</span> <span class="n">following</span> <span class="n">data</span> <span class="ow">is</span> <span class="n">properly</span> <span class="n">aligned</span><span class="p">,</span> <span class="n">particularly</span>
     <span class="n">that</span> <span class="n">sizeof</span> <span class="p">(</span><span class="n">heap_info</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">multiple</span> <span class="n">of</span>
     <span class="n">MALLOC_ALIGNMENT</span><span class="o">.</span> <span class="o">*/</span>
  <span class="n">char</span> <span class="n">pad</span><span class="p">[</span><span class="o">-</span><span class="mi">6</span> <span class="o">*</span> <span class="n">SIZE_SZ</span> <span class="o">&amp;</span> <span class="n">MALLOC_ALIGN_MASK</span><span class="p">];</span>
<span class="p">}</span> <span class="n">heap_info</span><span class="p">;</span>
</pre></div>
</div>
<p>该结构主要是描述堆的基本信息，包括</p>
<ul class="simple">
<li>堆对应的heap arena的地址</li>
<li>该堆前面的heap_info的地址，这里可以看到每个堆的heap_info是通过单向链表进行链接的</li>
<li>size表示当前堆的大小</li>
<li>最后一部分确保对齐（<strong>这里负数使用的缘由是什么呢</strong>？）</li>
</ul>
<p>看起来该结构应该是相当重要的，但是如果如果我们仔细看完整个malloc的实现的话，就会发现它出现的频率并不高。</p>
<p>程序刚开始执行时，每个线程是没有heap区域的。当其申请内存时，就需要一个结构来记录对应的信息，而heap_info的作用就是这个。而且当该heap的资源被使用完后，就必须得再次申请heap了。此外，一般申请的heap是不连续的，因此需要记录不同heap之间的链接结构。</p>
</div>
<div class="section" id="malloc-state">
<h3>malloc_state<a class="headerlink" href="#malloc-state" title="Permalink to this headline">¶</a></h3>
<p>该结构用于管理堆，记录每个arena当前的申请内存的具体状态，比如说有什么大小的空闲chunk，如何快速判断有没有什么大小的空闲的chunk。无论是对于thread arena还是说main arena，它们都只有一个malloc
state结构。由于thread的arena可能有多个，malloc state结构会在最新申请的arena中。</p>
<p><strong>注意，main arena的malloc_state并不是heap segment的一部分，而是一个全局变量，存储在libc.so的数据段。</strong></p>
<p>其结构如下</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="n">struct</span> <span class="n">malloc_state</span> <span class="p">{</span>
    <span class="o">/*</span> <span class="n">Serialize</span> <span class="n">access</span><span class="o">.</span>  <span class="o">*/</span>
    <span class="n">__libc_lock_define</span><span class="p">(,</span> <span class="n">mutex</span><span class="p">);</span>

    <span class="o">/*</span> <span class="n">Flags</span> <span class="p">(</span><span class="n">formerly</span> <span class="ow">in</span> <span class="n">max_fast</span><span class="p">)</span><span class="o">.</span>  <span class="o">*/</span>
    <span class="nb">int</span> <span class="n">flags</span><span class="p">;</span>

    <span class="o">/*</span> <span class="n">Fastbins</span> <span class="o">*/</span>
    <span class="n">mfastbinptr</span> <span class="n">fastbinsY</span><span class="p">[</span> <span class="n">NFASTBINS</span> <span class="p">];</span>

    <span class="o">/*</span> <span class="n">Base</span> <span class="n">of</span> <span class="n">the</span> <span class="n">topmost</span> <span class="n">chunk</span> <span class="o">--</span> <span class="ow">not</span> <span class="n">otherwise</span> <span class="n">kept</span> <span class="ow">in</span> <span class="n">a</span> <span class="nb">bin</span> <span class="o">*/</span>
    <span class="n">mchunkptr</span> <span class="n">top</span><span class="p">;</span>

    <span class="o">/*</span> <span class="n">The</span> <span class="n">remainder</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">most</span> <span class="n">recent</span> <span class="n">split</span> <span class="n">of</span> <span class="n">a</span> <span class="n">small</span> <span class="n">request</span> <span class="o">*/</span>
    <span class="n">mchunkptr</span> <span class="n">last_remainder</span><span class="p">;</span>

    <span class="o">/*</span> <span class="n">Normal</span> <span class="n">bins</span> <span class="n">packed</span> <span class="k">as</span> <span class="n">described</span> <span class="n">above</span> <span class="o">*/</span>
    <span class="n">mchunkptr</span> <span class="n">bins</span><span class="p">[</span> <span class="n">NBINS</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="p">];</span>

    <span class="o">/*</span> <span class="n">Bitmap</span> <span class="n">of</span> <span class="n">bins</span><span class="p">,</span> <span class="n">help</span> <span class="n">to</span> <span class="n">speed</span> <span class="n">up</span> <span class="n">the</span> <span class="n">process</span> <span class="n">of</span> <span class="n">determinating</span> <span class="k">if</span> <span class="n">a</span> <span class="n">given</span> <span class="nb">bin</span> <span class="ow">is</span> <span class="n">definitely</span> <span class="n">empty</span><span class="o">.*/</span>
    <span class="n">unsigned</span> <span class="nb">int</span> <span class="n">binmap</span><span class="p">[</span> <span class="n">BINMAPSIZE</span> <span class="p">];</span>

    <span class="o">/*</span> <span class="n">Linked</span> <span class="nb">list</span><span class="p">,</span> <span class="n">points</span> <span class="n">to</span> <span class="n">the</span> <span class="nb">next</span> <span class="n">arena</span> <span class="o">*/</span>
    <span class="n">struct</span> <span class="n">malloc_state</span> <span class="o">*</span><span class="nb">next</span><span class="p">;</span>

    <span class="o">/*</span> <span class="n">Linked</span> <span class="nb">list</span> <span class="k">for</span> <span class="n">free</span> <span class="n">arenas</span><span class="o">.</span>  <span class="n">Access</span> <span class="n">to</span> <span class="n">this</span> <span class="n">field</span> <span class="ow">is</span> <span class="n">serialized</span>
       <span class="n">by</span> <span class="n">free_list_lock</span> <span class="ow">in</span> <span class="n">arena</span><span class="o">.</span><span class="n">c</span><span class="o">.</span>  <span class="o">*/</span>
    <span class="n">struct</span> <span class="n">malloc_state</span> <span class="o">*</span><span class="n">next_free</span><span class="p">;</span>

    <span class="o">/*</span> <span class="n">Number</span> <span class="n">of</span> <span class="n">threads</span> <span class="n">attached</span> <span class="n">to</span> <span class="n">this</span> <span class="n">arena</span><span class="o">.</span>  <span class="mi">0</span> <span class="k">if</span> <span class="n">the</span> <span class="n">arena</span> <span class="ow">is</span> <span class="n">on</span>
       <span class="n">the</span> <span class="n">free</span> <span class="nb">list</span><span class="o">.</span>  <span class="n">Access</span> <span class="n">to</span> <span class="n">this</span> <span class="n">field</span> <span class="ow">is</span> <span class="n">serialized</span> <span class="n">by</span>
       <span class="n">free_list_lock</span> <span class="ow">in</span> <span class="n">arena</span><span class="o">.</span><span class="n">c</span><span class="o">.</span>  <span class="o">*/</span>
    <span class="n">INTERNAL_SIZE_T</span> <span class="n">attached_threads</span><span class="p">;</span>

    <span class="o">/*</span> <span class="n">Memory</span> <span class="n">allocated</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">system</span> <span class="ow">in</span> <span class="n">this</span> <span class="n">arena</span><span class="o">.</span>  <span class="o">*/</span>
    <span class="n">INTERNAL_SIZE_T</span> <span class="n">system_mem</span><span class="p">;</span>
    <span class="n">INTERNAL_SIZE_T</span> <span class="n">max_system_mem</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<ul class="simple">
<li>​ __libc_lock_define(, mutex);</li>
<li>该变量用于控制程序串行化访问同一个分配区，当一个线程获取了分配区之后，其它线程要想访问该分配区，就必须等待该线程分配完成候才能够使用。</li>
<li>flags</li>
<li>flags记录了分配区的一些标志，比如说bit0 记录了分配区是否有fast bin chunk，bit1标识分配区是否能返回连续的虚拟地址空间。</li>
<li>fastbinsY[ NFASTBINS ]</li>
<li>存放每个fast chunk链表头部的指针</li>
<li>top</li>
<li>指向分配区的top chunk</li>
<li>last_reminder</li>
<li>一个chunk分割之后剩下的那部分</li>
<li>bins</li>
<li>用于存储unstored bin，small bins和large bins的chunk链表。</li>
<li>binmap</li>
<li>ptmalloc用一个bit来标识该bit对应的bin中是否包含空闲chunk。</li>
</ul>
<p>关于其中每一个变量的具体意思，我们会在使用到的时候进行详细地说明。</p>
</div>
<div class="section" id="malloc-par">
<h3>malloc_par<a class="headerlink" href="#malloc-par" title="Permalink to this headline">¶</a></h3>
<p><strong>待补充</strong></p>
</div>
</div>
<div class="section" id="id6">
<h2>微观结构<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>上面的结构是堆的宏观结构，下面是堆中比较细节的结构，<strong>堆的利用主要集中在这些结构中</strong>。</p>
<div class="section" id="malloc-chunk">
<h3>malloc_chunk<a class="headerlink" href="#malloc-chunk" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id7">
<h4>概述<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h4>
<p>在程序的执行过程中，我们称由 malloc 申请的内存为 chunk ，该块内存在 ptmalloc 内部用 malloc_chunk 结构体来表示。当程序申请的chunk被free后，会被加入到相应的空闲管理列表中。</p>
<p>非常有意思的是，<strong>无论一个chunk的大小如何，处于分配状态还是释放状态，ptmalloc2 使用了一个统一的结构来表示chunk的内容</strong>。虽然它们使用了同一个数据结构，但是根据是否被释放，它们的表现形式会有所不同。</p>
<p>malloc_chunk的结构如下</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span>
  <span class="n">This</span> <span class="n">struct</span> <span class="n">declaration</span> <span class="ow">is</span> <span class="n">misleading</span> <span class="p">(</span><span class="n">but</span> <span class="n">accurate</span> <span class="ow">and</span> <span class="n">necessary</span><span class="p">)</span><span class="o">.</span>
  <span class="n">It</span> <span class="n">declares</span> <span class="n">a</span> <span class="s2">&quot;view&quot;</span> <span class="n">into</span> <span class="n">memory</span> <span class="n">allowing</span> <span class="n">access</span> <span class="n">to</span> <span class="n">necessary</span>
  <span class="n">fields</span> <span class="n">at</span> <span class="n">known</span> <span class="n">offsets</span> <span class="kn">from</span> <span class="nn">a</span> <span class="n">given</span> <span class="n">base</span><span class="o">.</span> <span class="n">See</span> <span class="n">explanation</span> <span class="n">below</span><span class="o">.</span>
<span class="o">*/</span>
<span class="n">struct</span> <span class="n">malloc_chunk</span> <span class="p">{</span>

  <span class="n">INTERNAL_SIZE_T</span>      <span class="n">prev_size</span><span class="p">;</span>  <span class="o">/*</span> <span class="n">Size</span> <span class="n">of</span> <span class="n">previous</span> <span class="n">chunk</span> <span class="p">(</span><span class="k">if</span> <span class="n">free</span><span class="p">)</span><span class="o">.</span>  <span class="o">*/</span>
  <span class="n">INTERNAL_SIZE_T</span>      <span class="n">size</span><span class="p">;</span>       <span class="o">/*</span> <span class="n">Size</span> <span class="ow">in</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">including</span> <span class="n">overhead</span><span class="o">.</span> <span class="o">*/</span>

  <span class="n">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">fd</span><span class="p">;</span>         <span class="o">/*</span> <span class="n">double</span> <span class="n">links</span> <span class="o">--</span> <span class="n">used</span> <span class="n">only</span> <span class="k">if</span> <span class="n">free</span><span class="o">.</span> <span class="o">*/</span>
  <span class="n">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">bk</span><span class="p">;</span>

  <span class="o">/*</span> <span class="n">Only</span> <span class="n">used</span> <span class="k">for</span> <span class="n">large</span> <span class="n">blocks</span><span class="p">:</span> <span class="n">pointer</span> <span class="n">to</span> <span class="nb">next</span> <span class="n">larger</span> <span class="n">size</span><span class="o">.</span>  <span class="o">*/</span>
  <span class="n">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">fd_nextsize</span><span class="p">;</span> <span class="o">/*</span> <span class="n">double</span> <span class="n">links</span> <span class="o">--</span> <span class="n">used</span> <span class="n">only</span> <span class="k">if</span> <span class="n">free</span><span class="o">.</span> <span class="o">*/</span>
  <span class="n">struct</span> <span class="n">malloc_chunk</span><span class="o">*</span> <span class="n">bk_nextsize</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>具体的，每个字段的解释如下</p>
<ul class="simple">
<li><strong>prev_size</strong>,
如果该chunk的<strong>物理相邻的前一chunk（即两个指针的地址的差值为前一chunk大小）</strong>是空闲的话，那该字段记录的是前一个chunk的大小(包括chunk头)。否则，该字段可以用来存储物理相邻的前一个chunk的数据。这里的前一chunk指的是较低地址的chunk。</li>
<li><strong>size</strong> ，该chunk的大小，大小必须是8（32位）的整数倍。如果申请的大小不是8的整数倍，会被转换满足大小的最小的8的倍数。该字段的低三个比特位对chunk的大小没有影响，它们从高到低分别表示</li>
<li>NON_MAIN_ARENA，记录当前chunk是否不属于主线程，1表示不属于，0表示属于。</li>
<li>IS_MAPPED，记录当前chunk是否是由mmap分配的。</li>
<li>PREV_INUSE，记录前一个chunk块是否被分配。一般来说，堆中第一个被分配的内存块的 size 字段的P位都会被设置为1，以便于防止访问前面的非法内存。而且，当一个 chunk 的 size 的 P 位为 0 时，我们能通过
prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲chunk之间的合并。</li>
<li><strong>fd，bk</strong>。 chunk处于分配状态时，从fd字段开始是用户的数据。chunk空闲时，其字段的含义如下</li>
<li>fd 指向下一个（非物理相邻）空闲的chunk</li>
<li>bk 指向上一个（非物理相邻）空闲的chunk</li>
<li>通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理</li>
<li><strong>fd_nextsize， bk_nextsize</strong>，也是只有chunk空闲的时候才使用，不过其用于较大的chunk（large chunk）。</li>
<li>fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含bin的头指针。</li>
<li>bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含bin的头指针。</li>
<li>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适chunk时挨个遍历。</strong></li>
</ul>
<p>一个已经分配的chunk的样子如下。<strong>我们称前两个字段称为chunk header，后面的部分称为user data。每次malloc申请得到的内存指针，其实指向user data的起始处。</strong></p>
<p>当一个chunk处于使用状态时，它的下一个chunk的prev_size域无效，所以下一个chunk的该部分也可以被当前chunk使用。<strong>这就是chunk中的空间复用。</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="n">chunk</span><span class="o">-&gt;</span> <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
        <span class="o">|</span>             <span class="n">Size</span> <span class="n">of</span> <span class="n">previous</span> <span class="n">chunk</span><span class="p">,</span> <span class="k">if</span> <span class="n">unallocated</span> <span class="p">(</span><span class="n">P</span> <span class="n">clear</span><span class="p">)</span>  <span class="o">|</span>
        <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
        <span class="o">|</span>             <span class="n">Size</span> <span class="n">of</span> <span class="n">chunk</span><span class="p">,</span> <span class="ow">in</span> <span class="nb">bytes</span>                     <span class="o">|</span><span class="n">A</span><span class="o">|</span><span class="n">M</span><span class="o">|</span><span class="n">P</span><span class="o">|</span>
  <span class="n">mem</span><span class="o">-&gt;</span> <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
        <span class="o">|</span>             <span class="n">User</span> <span class="n">data</span> <span class="n">starts</span> <span class="n">here</span><span class="o">...</span>                          <span class="o">.</span>
        <span class="o">.</span>                                                               <span class="o">.</span>
        <span class="o">.</span>             <span class="p">(</span><span class="n">malloc_usable_size</span><span class="p">()</span> <span class="nb">bytes</span><span class="p">)</span>                      <span class="o">.</span>
<span class="nb">next</span>    <span class="o">.</span>                                                               <span class="o">|</span>
<span class="n">chunk</span><span class="o">-&gt;</span> <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
        <span class="o">|</span>             <span class="p">(</span><span class="n">size</span> <span class="n">of</span> <span class="n">chunk</span><span class="p">,</span> <span class="n">but</span> <span class="n">used</span> <span class="k">for</span> <span class="n">application</span> <span class="n">data</span><span class="p">)</span>    <span class="o">|</span>
        <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
        <span class="o">|</span>             <span class="n">Size</span> <span class="n">of</span> <span class="nb">next</span> <span class="n">chunk</span><span class="p">,</span> <span class="ow">in</span> <span class="nb">bytes</span>                <span class="o">|</span><span class="n">A</span><span class="o">|</span><span class="mi">0</span><span class="o">|</span><span class="mi">1</span><span class="o">|</span>
        <span class="o">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</span>
</pre></div>
</div>
<p>被释放的 chunk 被记录在链表中（可能是循环双向链表，也可能是单向链表）。具体结构如下</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Size of previous chunk, if unallocated (P clear)  |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
`head:&#39; |             Size of chunk, in bytes                     |A|0|P|
  mem-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Forward pointer to next chunk in list             |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Back pointer to previous chunk in list            |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Unused space (may be 0 bytes long)                .
        .                                                               .
 next   .                                                               |
chunk-&gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
`foot:&#39; |             Size of chunk, in bytes                           |
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
        |             Size of next chunk, in bytes                |A|0|0|
        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</pre></div>
</div>
<p>可以发现，如果一个 chunk 处于 free 状态，那么会有两个位置记录其相应的大小，一个是本身的size字段会记录，一个是它后面额chunk会记录。此外，一般情况下，相邻的两个空闲 chunk 会被合并为一个 chunk
，通过prev_size 字段以及 size 字段也恰好有助于两个物理相邻的空闲chunk块进行合并。</p>
<p><strong>一些关于堆的约束，后面详细考虑</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/*
    The three exceptions to all this are:
     1. The special chunk `top&#39; doesn&#39;t bother using the
    trailing size field since there is no next contiguous chunk
    that would have to index off it. After initialization, `top&#39;
    is forced to always exist.  If it would become less than
    MINSIZE bytes long, it is replenished.
     2. Chunks allocated via mmap, which have the second-lowest-order
    bit M (IS_MMAPPED) set in their size fields.  Because they are
    allocated one-by-one, each must contain its own trailing size
    field.  If the M bit is set, the other bits are ignored
    (because mmapped chunks are neither in an arena, nor adjacent
    to a freed chunk).  The M bit is also used for chunks which
    originally came from a dumped heap via malloc_set_state in
    hooks.c.
     3. Chunks in fastbins are treated as allocated chunks from the
    point of view of the chunk allocator.  They are consolidated
    with their neighbors only in bulk, in malloc_consolidate.
*/
</pre></div>
</div>
</div>
<div class="section" id="chunk">
<h4>chunk相关宏<a class="headerlink" href="#chunk" title="Permalink to this headline">¶</a></h4>
<p>这里主要介绍关于 chun k的大小、对齐检查以及一些转换的宏代码。</p>
<p><strong>chunk 与 mem 指针头部的转换</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">conversion</span> <span class="kn">from</span> <span class="nn">malloc</span> <span class="n">headers</span> <span class="n">to</span> <span class="n">user</span> <span class="n">pointers</span><span class="p">,</span> <span class="ow">and</span> <span class="n">back</span> <span class="o">*/</span>

<span class="c1">#define chunk2mem(p) ((void *) ((char *) (p) + 2 * SIZE_SZ))</span>
<span class="c1">#define mem2chunk(mem) ((mchunkptr)((char *) (mem) -2 * SIZE_SZ))</span>
</pre></div>
</div>
<p><strong>最小的 chunk 大小</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">The</span> <span class="n">smallest</span> <span class="n">possible</span> <span class="n">chunk</span> <span class="o">*/</span>
<span class="c1">#define MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</span>
</pre></div>
</div>
<p>这里，offsetof 函数计算出 fd_nextsize 在 malloc_chunk 中的偏移，这说明最小的chunk至少要包含到bk指针。</p>
<p><strong>最小申请的堆内存大小</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">The</span> <span class="n">smallest</span> <span class="n">size</span> <span class="n">we</span> <span class="n">can</span> <span class="n">malloc</span> <span class="ow">is</span> <span class="n">an</span> <span class="n">aligned</span> <span class="n">minimal</span> <span class="n">chunk</span> <span class="o">*/</span>
<span class="o">//</span><span class="n">MALLOC_ALIGN_MASK</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">SIZE_SZ</span> <span class="o">-</span><span class="mi">1</span>
<span class="c1">#define MINSIZE                                                                \</span>
    <span class="p">(</span><span class="n">unsigned</span> <span class="n">long</span><span class="p">)</span> <span class="p">(((</span><span class="n">MIN_CHUNK_SIZE</span> <span class="o">+</span> <span class="n">MALLOC_ALIGN_MASK</span><span class="p">)</span> <span class="o">&amp;</span>                   \
                      <span class="o">~</span><span class="n">MALLOC_ALIGN_MASK</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>检查分配给用户的内存是否对齐</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/* Check if m has acceptable alignment */
// MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1
#define aligned_OK(m) (((unsigned long) (m) &amp; MALLOC_ALIGN_MASK) == 0)

#define misaligned_chunk(p)                                                    \
    ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \
     MALLOC_ALIGN_MASK)
</pre></div>
</div>
<p><strong>请求字节数判断</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span>
   <span class="n">Check</span> <span class="k">if</span> <span class="n">a</span> <span class="n">request</span> <span class="ow">is</span> <span class="n">so</span> <span class="n">large</span> <span class="n">that</span> <span class="n">it</span> <span class="n">would</span> <span class="n">wrap</span> <span class="n">around</span> <span class="n">zero</span> <span class="n">when</span>
   <span class="n">padded</span> <span class="ow">and</span> <span class="n">aligned</span><span class="o">.</span> <span class="n">To</span> <span class="n">simplify</span> <span class="n">some</span> <span class="n">other</span> <span class="n">code</span><span class="p">,</span> <span class="n">the</span> <span class="n">bound</span> <span class="ow">is</span> <span class="n">made</span>
   <span class="n">low</span> <span class="n">enough</span> <span class="n">so</span> <span class="n">that</span> <span class="n">adding</span> <span class="n">MINSIZE</span> <span class="n">will</span> <span class="n">also</span> <span class="ow">not</span> <span class="n">wrap</span> <span class="n">around</span> <span class="n">zero</span><span class="o">.</span>
 <span class="o">*/</span>

<span class="c1">#define REQUEST_OUT_OF_RANGE(req)                                              \</span>
    <span class="p">((</span><span class="n">unsigned</span> <span class="n">long</span><span class="p">)</span> <span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">unsigned</span> <span class="n">long</span><span class="p">)</span> <span class="p">(</span><span class="n">INTERNAL_SIZE_T</span><span class="p">)(</span><span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">MINSIZE</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>将用户请求内存大小转为实际分配大小</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>/* pad request bytes into a usable size -- internal version */
//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1
#define request2size(req)                                                      \
    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \
         ? MINSIZE                                                             \
         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)

/*  Same, except also perform argument check */

#define checked_request2size(req, sz)                                          \
    if (REQUEST_OUT_OF_RANGE(req)) {                                           \
        __set_errno(ENOMEM);                                                   \
        return 0;                                                              \
    }                                                                          \
    (sz) = request2size(req);
</pre></div>
</div>
<p>当一个chunk处于已分配状态时，它的物理相邻的下一个 chunk 的 prev_size 字段必然是无效的，故而这个字段就可以被当前这个 chunk 使用。这就是 ptmalloc 中 chunk
间的复用。因此，实际要被分配的内存的大小应该为先添加上存储本chunk的大小字段的字节大小，然后再按照MALLOC的规定进行对齐，这里之所以不需要再加上prev_size字段所占据的大小，就是可以复用下一个chunk的这一字段作为当前chunk的数据段。除此之外，我们必须得确保
chunk 实际所能利用的大小至少可以存储 prev_size，size，fd，bk 这四个字段，所以我们会将其与MINSIZE进行比较。<strong>这里我们是不能去借用下一个chunk的 prev_size
来存储数据的，因为当chunk块空闲时，下一个chunk记录的是当前chunk的大小，所以是不能借用的</strong>。
如果调整后不满足最低要求，那么我们就需要直接分配MINSIZE字节，否则，我们就可以按照之前的计算公式来进行计算。</p>
<p><strong>需要注意的是，通过这样的计算公式得到的 size 最终一定是满足用户需要的。</strong></p>
<p><strong>标记位相关</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">size</span> <span class="n">field</span> <span class="ow">is</span> <span class="ow">or</span><span class="s1">&#39;ed with PREV_INUSE when previous adjacent chunk in use */</span>
<span class="c1">#define PREV_INUSE 0x1</span>

<span class="o">/*</span> <span class="n">extract</span> <span class="n">inuse</span> <span class="n">bit</span> <span class="n">of</span> <span class="n">previous</span> <span class="n">chunk</span> <span class="o">*/</span>
<span class="c1">#define prev_inuse(p) ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span>

<span class="o">/*</span> <span class="n">size</span> <span class="n">field</span> <span class="ow">is</span> <span class="ow">or</span><span class="s1">&#39;ed with IS_MMAPPED if the chunk was obtained with mmap() */</span>
<span class="c1">#define IS_MMAPPED 0x2</span>

<span class="o">/*</span> <span class="n">check</span> <span class="k">for</span> <span class="n">mmap</span><span class="p">()</span><span class="s1">&#39;ed chunk */</span>
<span class="c1">#define chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span>

<span class="o">/*</span> <span class="n">size</span> <span class="n">field</span> <span class="ow">is</span> <span class="ow">or</span><span class="s1">&#39;ed with NON_MAIN_ARENA if the chunk was obtained</span>
   <span class="kn">from</span> <span class="nn">a</span> <span class="n">non</span><span class="o">-</span><span class="n">main</span> <span class="n">arena</span><span class="o">.</span>  <span class="n">This</span> <span class="ow">is</span> <span class="n">only</span> <span class="nb">set</span> <span class="n">immediately</span> <span class="n">before</span> <span class="n">handing</span>
   <span class="n">the</span> <span class="n">chunk</span> <span class="n">to</span> <span class="n">the</span> <span class="n">user</span><span class="p">,</span> <span class="k">if</span> <span class="n">necessary</span><span class="o">.</span>  <span class="o">*/</span>
 <span class="n">NON_MAIN_ARENA</span> <span class="mh">0x4</span>

<span class="o">/*</span> <span class="n">Check</span> <span class="k">for</span> <span class="n">chunk</span> <span class="kn">from</span> <span class="nn">main</span> <span class="n">arena</span><span class="o">.</span>  <span class="o">*/</span>
<span class="c1">#define chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span>

<span class="o">/*</span> <span class="n">Mark</span> <span class="n">a</span> <span class="n">chunk</span> <span class="k">as</span> <span class="ow">not</span> <span class="n">being</span> <span class="n">on</span> <span class="n">the</span> <span class="n">main</span> <span class="n">arena</span><span class="o">.</span>  <span class="o">*/</span>
<span class="c1">#define set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span>

<span class="o">/*</span>
   <span class="n">Bits</span> <span class="n">to</span> <span class="n">mask</span> <span class="n">off</span> <span class="n">when</span> <span class="n">extracting</span> <span class="n">size</span>
   <span class="n">Note</span><span class="p">:</span> <span class="n">IS_MMAPPED</span> <span class="ow">is</span> <span class="n">intentionally</span> <span class="ow">not</span> <span class="n">masked</span> <span class="n">off</span> <span class="kn">from</span> <span class="nn">size</span> <span class="n">field</span> <span class="ow">in</span>
   <span class="n">macros</span> <span class="k">for</span> <span class="n">which</span> <span class="n">mmapped</span> <span class="n">chunks</span> <span class="n">should</span> <span class="n">never</span> <span class="n">be</span> <span class="n">seen</span><span class="o">.</span> <span class="n">This</span> <span class="n">should</span>
   <span class="n">cause</span> <span class="n">helpful</span> <span class="n">core</span> <span class="n">dumps</span> <span class="n">to</span> <span class="n">occur</span> <span class="k">if</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">tried</span> <span class="n">by</span> <span class="n">accident</span> <span class="n">by</span>
   <span class="n">people</span> <span class="n">extending</span> <span class="ow">or</span> <span class="n">adapting</span> <span class="n">this</span> <span class="n">malloc</span><span class="o">.</span>
 <span class="o">*/</span>
<span class="c1">##define SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span>
</pre></div>
</div>
<p><strong>获取chunk size</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Get</span> <span class="n">size</span><span class="p">,</span> <span class="n">ignoring</span> <span class="n">use</span> <span class="n">bits</span> <span class="o">*/</span>
<span class="c1">#define chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span>

<span class="o">/*</span> <span class="n">Like</span> <span class="n">chunksize</span><span class="p">,</span> <span class="n">but</span> <span class="n">do</span> <span class="ow">not</span> <span class="n">mask</span> <span class="n">SIZE_BITS</span><span class="o">.</span>  <span class="o">*/</span>
<span class="c1">#define chunksize_nomask(p) ((p)-&gt;mchunk_size)</span>
</pre></div>
</div>
<p><strong>获取下一个物理相邻的chunk</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Ptr</span> <span class="n">to</span> <span class="nb">next</span> <span class="n">physical</span> <span class="n">malloc_chunk</span><span class="o">.</span> <span class="o">*/</span>
<span class="c1">#define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span>
</pre></div>
</div>
<p><strong>获取前一个chunk的信息</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Size</span> <span class="n">of</span> <span class="n">the</span> <span class="n">chunk</span> <span class="n">below</span> <span class="n">P</span><span class="o">.</span>  <span class="n">Only</span> <span class="n">valid</span> <span class="k">if</span> <span class="n">prev_inuse</span> <span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span>  <span class="o">*/</span>
<span class="c1">#define prev_size(p) ((p)-&gt;mchunk_prev_size)</span>

<span class="o">/*</span> <span class="n">Set</span> <span class="n">the</span> <span class="n">size</span> <span class="n">of</span> <span class="n">the</span> <span class="n">chunk</span> <span class="n">below</span> <span class="n">P</span><span class="o">.</span>  <span class="n">Only</span> <span class="n">valid</span> <span class="k">if</span> <span class="n">prev_inuse</span> <span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span>  <span class="o">*/</span>
<span class="c1">#define set_prev_size(p, sz) ((p)-&gt;mchunk_prev_size = (sz))</span>

<span class="o">/*</span> <span class="n">Ptr</span> <span class="n">to</span> <span class="n">previous</span> <span class="n">physical</span> <span class="n">malloc_chunk</span><span class="o">.</span>  <span class="n">Only</span> <span class="n">valid</span> <span class="k">if</span> <span class="n">prev_inuse</span> <span class="p">(</span><span class="n">P</span><span class="p">)</span><span class="o">.</span>  <span class="o">*/</span>
<span class="c1">#define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span>
</pre></div>
</div>
<p><strong>当前chunk使用状态相关操作</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">extract</span> <span class="n">p</span><span class="s1">&#39;s inuse bit */</span>
<span class="c1">#define inuse(p)                                                               \</span>
    <span class="p">((((</span><span class="n">mchunkptr</span><span class="p">)(((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">+</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span><span class="o">-&gt;</span><span class="n">mchunk_size</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">PREV_INUSE</span><span class="p">)</span>

<span class="o">/*</span> <span class="nb">set</span><span class="o">/</span><span class="n">clear</span> <span class="n">chunk</span> <span class="k">as</span> <span class="n">being</span> <span class="n">inuse</span> <span class="n">without</span> <span class="n">otherwise</span> <span class="n">disturbing</span> <span class="o">*/</span>
<span class="c1">#define set_inuse(p)                                                           \</span>
    <span class="p">((</span><span class="n">mchunkptr</span><span class="p">)(((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">+</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span><span class="o">-&gt;</span><span class="n">mchunk_size</span> <span class="o">|=</span> <span class="n">PREV_INUSE</span>

<span class="c1">#define clear_inuse(p)                                                         \</span>
    <span class="p">((</span><span class="n">mchunkptr</span><span class="p">)(((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">+</span> <span class="n">chunksize</span><span class="p">(</span><span class="n">p</span><span class="p">)))</span><span class="o">-&gt;</span><span class="n">mchunk_size</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PREV_INUSE</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>设置chunk的size字段</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Set</span> <span class="n">size</span> <span class="n">at</span> <span class="n">head</span><span class="p">,</span> <span class="n">without</span> <span class="n">disturbing</span> <span class="n">its</span> <span class="n">use</span> <span class="n">bit</span> <span class="o">*/</span>
<span class="o">//</span> <span class="n">SIZE_BITS</span> <span class="o">=</span> <span class="mi">7</span>
<span class="c1">#define set_head_size(p, s)                                                    \</span>
    <span class="p">((</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mchunk_size</span> <span class="o">=</span> <span class="p">(((</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mchunk_size</span> <span class="o">&amp;</span> <span class="n">SIZE_BITS</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">s</span><span class="p">)))</span>

<span class="o">/*</span> <span class="n">Set</span> <span class="n">size</span><span class="o">/</span><span class="n">use</span> <span class="n">field</span> <span class="o">*/</span>
<span class="c1">#define set_head(p, s) ((p)-&gt;mchunk_size = (s))</span>

<span class="o">/*</span> <span class="n">Set</span> <span class="n">size</span> <span class="n">at</span> <span class="n">footer</span> <span class="p">(</span><span class="n">only</span> <span class="n">when</span> <span class="n">chunk</span> <span class="ow">is</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">use</span><span class="p">)</span> <span class="o">*/</span>
<span class="c1">#define set_foot(p, s)                                                         \</span>
    <span class="p">(((</span><span class="n">mchunkptr</span><span class="p">)((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="p">)))</span><span class="o">-&gt;</span><span class="n">mchunk_prev_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span><span class="p">))</span>
</pre></div>
</div>
<p><strong>获取指定偏移的chunk</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">Treat</span> <span class="n">space</span> <span class="n">at</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">offset</span> <span class="k">as</span> <span class="n">a</span> <span class="n">chunk</span> <span class="o">*/</span>
<span class="c1">#define chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))</span>
</pre></div>
</div>
<p><strong>指定偏移处chunk使用状态相关操作</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">check</span><span class="o">/</span><span class="nb">set</span><span class="o">/</span><span class="n">clear</span> <span class="n">inuse</span> <span class="n">bits</span> <span class="ow">in</span> <span class="n">known</span> <span class="n">places</span> <span class="o">*/</span>
<span class="c1">#define inuse_bit_at_offset(p, s)                                              \</span>
    <span class="p">(((</span><span class="n">mchunkptr</span><span class="p">)(((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="p">)))</span><span class="o">-&gt;</span><span class="n">mchunk_size</span> <span class="o">&amp;</span> <span class="n">PREV_INUSE</span><span class="p">)</span>

<span class="c1">#define set_inuse_bit_at_offset(p, s)                                          \</span>
    <span class="p">(((</span><span class="n">mchunkptr</span><span class="p">)(((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="p">)))</span><span class="o">-&gt;</span><span class="n">mchunk_size</span> <span class="o">|=</span> <span class="n">PREV_INUSE</span><span class="p">)</span>

<span class="c1">#define clear_inuse_bit_at_offset(p, s)                                        \</span>
    <span class="p">(((</span><span class="n">mchunkptr</span><span class="p">)(((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="p">)))</span><span class="o">-&gt;</span><span class="n">mchunk_size</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">PREV_INUSE</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="bin">
<h3>bin<a class="headerlink" href="#bin" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id8">
<h4>概述<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h4>
<p>我们曾经说过，用户释放掉的 chunk 不会马上归还给系统，ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲的chunk。当用户再一次请求分配内存时，ptmalloc
分配器会试图在空闲的chunk中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。</p>
<p>在具体的实现中，ptmalloc 采用分箱式方法对空闲的 chunk 进行管理。首先，它会根据空闲的 chunk 的大小以及使用状态将 chunk 初步分为4类：fast bins，small bins，large bins，unsorted
bin。每类中仍然有更细的划分，相似大小的chunk会用双向链表链接起来。也就是说，在每类bin的内部仍然会有多个互不相关的链表来保存不同大小的chunk。</p>
<p>对于 small bins，large bins，unsorted bin 来说，Ptmalloc 将它们维护在同一个数组中。这些bin对应的数据结构在 malloc_state 中，如下</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="c1">##define NBINS 128</span>
<span class="o">/*</span> <span class="n">Normal</span> <span class="n">bins</span> <span class="n">packed</span> <span class="k">as</span> <span class="n">described</span> <span class="n">above</span> <span class="o">*/</span>
<span class="n">mchunkptr</span> <span class="n">bins</span><span class="p">[</span> <span class="n">NBINS</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span> <span class="p">];</span>
</pre></div>
</div>
<p>虽然每个 bin 的表头使用 mchunkptr 这个数据结构，但是这只是为了方便我们将每个 bin 转化为 malloc_chunk 指针。我们在使用时，会将这个指针当做一个 chunk 的 fd 或 bk
指针来操作，以便于将处于空闲的堆块链接在一起。这样可以节省空间，并提高可用性。那到底是怎么节省的呢？这里我们以32位系统为例</p>
<table border="1" class="docutils">
<colgroup>
<col width="10%" />
<col width="25%" />
<col width="20%" />
<col width="25%" />
<col width="20%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">含义</th>
<th class="head">bin1的fd/bin2的prev_size</th>
<th class="head">bin1的bk/bin2的size</th>
<th class="head">bin2的fd/bin3的prev_size</th>
<th class="head">bin2的bk/bin3的size</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>bin下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>可以看出除了第一个bin（unsorted bin）外，后面的每个bin会共享前面的bin的字段，将其视为malloc
chunk部分的prev_size和size。这里也说明了一个问题，<strong>bin的下标和我们所说的第几个bin并不是一致的。同时，bin表头的 chunk 的 prev_size 与 size 字段不能随便修改，因为这两个字段是被其它bin所利用的。</strong></p>
<p>相应的宏如下</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="n">typedef</span> <span class="n">struct</span> <span class="n">malloc_chunk</span> <span class="o">*</span><span class="n">mbinptr</span><span class="p">;</span>

<span class="o">/*</span> <span class="n">addressing</span> <span class="o">--</span> <span class="n">note</span> <span class="n">that</span> <span class="n">bin_at</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="n">does</span> <span class="ow">not</span> <span class="n">exist</span> <span class="o">*/</span>
<span class="c1">#define bin_at(m, i)                                                           \</span>
    <span class="p">(</span><span class="n">mbinptr</span><span class="p">)(((</span><span class="n">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="p">((</span><span class="n">m</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">bins</span><span class="p">[</span> <span class="p">((</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="p">]))</span> <span class="o">-</span>                        \
              <span class="n">offsetof</span><span class="p">(</span><span class="n">struct</span> <span class="n">malloc_chunk</span><span class="p">,</span> <span class="n">fd</span><span class="p">))</span>

<span class="o">/*</span> <span class="n">analog</span> <span class="n">of</span> <span class="o">++</span><span class="nb">bin</span> <span class="o">*/</span>
<span class="o">//</span><span class="n">获取下一个bin的地址</span>
<span class="c1">#define next_bin(b) ((mbinptr)((char *) (b) + (sizeof(mchunkptr) &lt;&lt; 1)))</span>

<span class="o">/*</span> <span class="n">Reminders</span> <span class="n">about</span> <span class="nb">list</span> <span class="n">directionality</span> <span class="n">within</span> <span class="n">bins</span> <span class="o">*/</span>
<span class="o">//</span> <span class="n">这两个宏可以用来遍历bin</span>
<span class="o">//</span> <span class="n">获取</span> <span class="nb">bin</span> <span class="n">的位于链表头的</span> <span class="n">chunk</span>
<span class="c1">#define first(b) ((b)-&gt;fd)</span>
<span class="o">//</span> <span class="n">获取</span> <span class="nb">bin</span> <span class="n">的位于链表尾的</span> <span class="n">chunk</span>
<span class="c1">#define last(b) ((b)-&gt;bk)</span>
</pre></div>
</div>
<p>数组中的bin依次介绍如下</p>
<ol class="arabic simple">
<li>第一个为 unsorted bin，字如其面，这里面的 chunk 没有进行排序，存储的 chunk 比较杂。</li>
<li>索引从 2 到 63 的 bin 称为 small bin，同一个 small bin 中的chunk的大小相同。两个相邻索引的 small bin中的 chunk 大小相差的字节数为<strong>2个机器字长</strong>，即32位相差8字节，64位相差16字节。</li>
<li>small bins 后面的 bin 被称作 large bins。large bins 中的每一个 bin 都包含一定范围内的chunk，其中的chunk按fd指针的顺序从大到小排列。相同大小的chunk同样按照最近使用顺序排列。</li>
</ol>
<p>此外，上述这些bin的排布都会遵循一个原则：<strong>任意两个物理相邻的空闲chunk不能在一起</strong>。</p>
<p>需要注意的是，并不是所有的 chunk 被释放后就立即被放到 bin 中。ptmalloc 为了提高分配的速度，会把一些小的 chunk <strong>先</strong>放到 fast bins 的容器内。<strong>而且，fastbin 容器中的 chunk
的使用标记总是被置位的，所以不满足上面的原则。</strong></p>
</div>
<div class="section" id="fast-bin">
<h4>fast bin<a class="headerlink" href="#fast-bin" title="Permalink to this headline">¶</a></h4>
<p>对于大多数程序来说，经常会申请以及释放一些比较小的内存块。如果我们将一些较小的 chunk 释放之后发现存在与之相邻的空闲的 chunk 并将它们进行合并，当我们下一次再次申请相应大小的 chunk 时，就需要对 chunk
进行分割，这样就大大降低了堆的利用效率。<strong>因为我们把大部分时间花在了合并、分割以及中间检查的过程中。</strong>因此，ptmalloc 中专门设计了 fast bin，对应的变量就是 malloc state 中的 fastbinsY</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span>
   <span class="n">Fastbins</span>

    <span class="n">An</span> <span class="n">array</span> <span class="n">of</span> <span class="n">lists</span> <span class="n">holding</span> <span class="n">recently</span> <span class="n">freed</span> <span class="n">small</span> <span class="n">chunks</span><span class="o">.</span>  <span class="n">Fastbins</span>
    <span class="n">are</span> <span class="ow">not</span> <span class="n">doubly</span> <span class="n">linked</span><span class="o">.</span>  <span class="n">It</span> <span class="ow">is</span> <span class="n">faster</span> <span class="n">to</span> <span class="n">single</span><span class="o">-</span><span class="n">link</span> <span class="n">them</span><span class="p">,</span> <span class="ow">and</span>
    <span class="n">since</span> <span class="n">chunks</span> <span class="n">are</span> <span class="n">never</span> <span class="n">removed</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">middles</span> <span class="n">of</span> <span class="n">these</span> <span class="n">lists</span><span class="p">,</span>
    <span class="n">double</span> <span class="n">linking</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">necessary</span><span class="o">.</span> <span class="n">Also</span><span class="p">,</span> <span class="n">unlike</span> <span class="n">regular</span> <span class="n">bins</span><span class="p">,</span> <span class="n">they</span>
    <span class="n">are</span> <span class="ow">not</span> <span class="n">even</span> <span class="n">processed</span> <span class="ow">in</span> <span class="n">FIFO</span> <span class="n">order</span> <span class="p">(</span><span class="n">they</span> <span class="n">use</span> <span class="n">faster</span> <span class="n">LIFO</span><span class="p">)</span> <span class="n">since</span>
    <span class="n">ordering</span> <span class="n">doesn</span><span class="s1">&#39;t much matter in the transient contexts in which</span>
    <span class="n">fastbins</span> <span class="n">are</span> <span class="n">normally</span> <span class="n">used</span><span class="o">.</span>

    <span class="n">Chunks</span> <span class="ow">in</span> <span class="n">fastbins</span> <span class="n">keep</span> <span class="n">their</span> <span class="n">inuse</span> <span class="n">bit</span> <span class="nb">set</span><span class="p">,</span> <span class="n">so</span> <span class="n">they</span> <span class="n">cannot</span>
    <span class="n">be</span> <span class="n">consolidated</span> <span class="k">with</span> <span class="n">other</span> <span class="n">free</span> <span class="n">chunks</span><span class="o">.</span> <span class="n">malloc_consolidate</span>
    <span class="n">releases</span> <span class="nb">all</span> <span class="n">chunks</span> <span class="ow">in</span> <span class="n">fastbins</span> <span class="ow">and</span> <span class="n">consolidates</span> <span class="n">them</span> <span class="k">with</span>
    <span class="n">other</span> <span class="n">free</span> <span class="n">chunks</span><span class="o">.</span>
 <span class="o">*/</span>
<span class="n">typedef</span> <span class="n">struct</span> <span class="n">malloc_chunk</span> <span class="o">*</span><span class="n">mfastbinptr</span><span class="p">;</span>

<span class="o">/*</span>
    <span class="n">This</span> <span class="ow">is</span> <span class="ow">in</span> <span class="n">malloc_state</span><span class="o">.</span>
    <span class="o">/*</span> <span class="n">Fastbins</span> <span class="o">*/</span>
    <span class="n">mfastbinptr</span> <span class="n">fastbinsY</span><span class="p">[</span> <span class="n">NFASTBINS</span> <span class="p">];</span>
<span class="o">*/</span>
</pre></div>
</div>
<p>为了更加高效地利用 fast bin，glibc 直接采用单向链表对其中的每个 bin 进行组织，并且<strong>每个 bin 采取 LIFO 策略</strong>，最近释放的 chunk 会更早地被分配，所以会更加适合于局部性。也就是说，当用户需要的 chunk
的大小小于 fastbin 的最大大小时， ptmalloc 会首先判断 fastbin 中相应的 bin 中是否有对应大小的空闲块，如果有的话，就会直接从这个 bin 中获取 chunk。如果没有的话，ptmalloc才会做接下来的一系列操作。</p>
<p>默认情况下（32位为例）， fastbin 中默认支持最大的 chunk 的数据空间大小为64字节。但是其可以支持的chunk的数据空间最大为80字节。除此之外， fastbin 最多可以支持的 bin 的个数为 10
个，从数据空间为8字节开始一直到80字节，定义如下</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>##define NFASTBINS (fastbin_index(request2size(MAX_FAST_SIZE)) + 1)

##ifndef DEFAULT_MXFAST
##define DEFAULT_MXFAST (64 * SIZE_SZ / 4)
##endif

/* The maximum fastbin request size we support */
##define MAX_FAST_SIZE (80 * SIZE_SZ / 4)

/*
   Since the lowest 2 bits in max_fast don&#39;t matter in size comparisons,
   they are used as flags.
 */

/*
   FASTCHUNKS_BIT held in max_fast indicates that there are probably
   some fastbin chunks. It is set true on entering a chunk into any
   fastbin, and cleared only in malloc_consolidate.

   The truth value is inverted so that have_fastchunks will be true
   upon startup (since statics are zero-filled), simplifying
   initialization checks.
 */
//判断分配区是否有 fast bin chunk，1表示没有
##define FASTCHUNKS_BIT (1U)

##define have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)
##define clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)
##define set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)

/*
   NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous
   regions.  Otherwise, contiguity is exploited in merging together,
   when possible, results from consecutive MORECORE calls.

   The initial value comes from MORECORE_CONTIGUOUS, but is
   changed dynamically if mmap is ever used as an sbrk substitute.
 */
// MORECODE是否返回连续的内存区域。
// 主分配区中的MORECORE其实为sbr()，默认返回连续虚拟地址空间
// 非主分配区使用mmap()分配大块虚拟内存，然后进行切分来模拟主分配区的行为
// 而默认情况下mmap映射区域是不保证虚拟地址空间连续的，所以非主分配区默认分配非连续虚拟地址空间。
##define NONCONTIGUOUS_BIT (2U)

##define contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)
##define noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)
##define set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)
##define set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)

/* ARENA_CORRUPTION_BIT is set if a memory corruption was detected on the
   arena.  Such an arena is no longer used to allocate chunks.  Chunks
   allocated in that arena before detecting corruption are not freed.  */

##define ARENA_CORRUPTION_BIT (4U)

##define arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))
##define set_arena_corrupt(A) ((A)-&gt;flags |= ARENA_CORRUPTION_BIT)

/*
   Set value of max_fast.
   Use impossibly small value if 0.
   Precondition: there are no existing fastbin chunks.
   Setting the value clears fastchunk bit but preserves noncontiguous bit.
 */

##define set_max_fast(s)                                                        \
    global_max_fast =                                                          \
        (((s) == 0) ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))
##define get_max_fast() global_max_fast
</pre></div>
</div>
<p>ptmalloc 默认情况下会调用 set_max_fast(s) 将全局变量 global_max_fast 设置为 DEFAULT_MXFAST，也就是设置 fast bins 中 chunk 的最大值。当 MAX_FAST_SIZE 被设置为 0 时，系统就不会支持 fastbin 。</p>
<p><strong>fastbin的索引</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>##define fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[ idx ])

/* offset 2 to use otherwise unindexable first 2 bins */
// 这里要减2，否则的话，前两个bin没有办法索引到。
##define fastbin_index(sz)                                                      \
    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)
</pre></div>
</div>
<p><strong>需要特别注意的是，fastbin 范围的 chunk 的 inuse 始终被置为 1。因此它们不会和其它被释放的chunk合并。</strong></p>
<p>但是当释放的 chunk 与该 chunk 相邻的空闲 chunk 合并后的大小大于FASTBIN_CONSOLIDATION_THRESHOLD时，内存碎片可能比较多了，我们就需要把fast bins中的chunk都进行合并，以减少内存碎片对系统的影响。</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span>
   <span class="n">FASTBIN_CONSOLIDATION_THRESHOLD</span> <span class="ow">is</span> <span class="n">the</span> <span class="n">size</span> <span class="n">of</span> <span class="n">a</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">free</span><span class="p">()</span>
   <span class="n">that</span> <span class="n">triggers</span> <span class="n">automatic</span> <span class="n">consolidation</span> <span class="n">of</span> <span class="n">possibly</span><span class="o">-</span><span class="n">surrounding</span>
   <span class="n">fastbin</span> <span class="n">chunks</span><span class="o">.</span> <span class="n">This</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">heuristic</span><span class="p">,</span> <span class="n">so</span> <span class="n">the</span> <span class="n">exact</span> <span class="n">value</span> <span class="n">should</span> <span class="ow">not</span>
   <span class="n">matter</span> <span class="n">too</span> <span class="n">much</span><span class="o">.</span> <span class="n">It</span> <span class="ow">is</span> <span class="n">defined</span> <span class="n">at</span> <span class="n">half</span> <span class="n">the</span> <span class="n">default</span> <span class="n">trim</span> <span class="n">threshold</span> <span class="k">as</span> <span class="n">a</span>
   <span class="n">compromise</span> <span class="n">heuristic</span> <span class="n">to</span> <span class="n">only</span> <span class="n">attempt</span> <span class="n">consolidation</span> <span class="k">if</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">likely</span>
   <span class="n">to</span> <span class="n">lead</span> <span class="n">to</span> <span class="n">trimming</span><span class="o">.</span> <span class="n">However</span><span class="p">,</span> <span class="n">it</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">dynamically</span> <span class="n">tunable</span><span class="p">,</span> <span class="n">since</span>
   <span class="n">consolidation</span> <span class="n">reduces</span> <span class="n">fragmentation</span> <span class="n">surrounding</span> <span class="n">large</span> <span class="n">chunks</span> <span class="n">even</span>
   <span class="k">if</span> <span class="n">trimming</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">used</span><span class="o">.</span>
 <span class="o">*/</span>

<span class="c1">##define FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)</span>
</pre></div>
</div>
<p><strong>malloc_consolidate函数可以将fastbin中所有的chunk释放并合并在一起。？？？</strong></p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span>
    <span class="n">Chunks</span> <span class="ow">in</span> <span class="n">fastbins</span> <span class="n">keep</span> <span class="n">their</span> <span class="n">inuse</span> <span class="n">bit</span> <span class="nb">set</span><span class="p">,</span> <span class="n">so</span> <span class="n">they</span> <span class="n">cannot</span>
    <span class="n">be</span> <span class="n">consolidated</span> <span class="k">with</span> <span class="n">other</span> <span class="n">free</span> <span class="n">chunks</span><span class="o">.</span> <span class="n">malloc_consolidate</span>
    <span class="n">releases</span> <span class="nb">all</span> <span class="n">chunks</span> <span class="ow">in</span> <span class="n">fastbins</span> <span class="ow">and</span> <span class="n">consolidates</span> <span class="n">them</span> <span class="k">with</span>
    <span class="n">other</span> <span class="n">free</span> <span class="n">chunks</span><span class="o">.</span>
 <span class="o">*/</span>
</pre></div>
</div>
</div>
<div class="section" id="small-bin">
<h4>small bin<a class="headerlink" href="#small-bin" title="Permalink to this headline">¶</a></h4>
<p>small bins 中每个 chunk 的大小与其所在的bin的index的关系为：chunk_size =2 * SIZE_SZ *index，具体如下</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="42%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">下标</th>
<th class="head">SIZE_SZ=4（32位）</th>
<th class="head">SIZE_SZ=8（64位）</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>2</td>
<td>16</td>
<td>32</td>
</tr>
<tr class="row-odd"><td>3</td>
<td>24</td>
<td>48</td>
</tr>
<tr class="row-even"><td>4</td>
<td>32</td>
<td>64</td>
</tr>
<tr class="row-odd"><td>5</td>
<td>40</td>
<td>80</td>
</tr>
<tr class="row-even"><td>x</td>
<td>2*4*x</td>
<td>2*8*x</td>
</tr>
<tr class="row-odd"><td>63</td>
<td>504</td>
<td>1008</td>
</tr>
</tbody>
</table>
<p>small
bins中一共有62个链表，每个链表中存储的chunk大小都一致。比如对于32位系统来说，下标2对应的双向链表中存储的chunk大小为均为16字节。每个链表都有链表头结点，这样可以方便对于链表内部结点的管理。此外，<strong>small
bins中每个bin对应的链表采用FIFO的规则</strong>，所以同一个链表中先被释放的chunk会先被分配出去。</p>
<p>small bin相关的宏如下</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>##define NSMALLBINS 64
##define SMALLBIN_WIDTH MALLOC_ALIGNMENT
// 是否需要对small bin的下标进行纠正
##define SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)

##define MIN_LARGE_SIZE ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)
//判断chunk的大小是否在small bin范围内
##define in_smallbin_range(sz)                                                  \
    ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)
// 根据chunk的大小得到small bin对应的索引。
##define smallbin_index(sz)                                                     \
    ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4)                          \
                           : (((unsigned) (sz)) &gt;&gt; 3)) +                       \
     SMALLBIN_CORRECTION)
</pre></div>
</div>
<p><strong>或许，大家会很疑惑，那 fastbin 与 small bin 中 chunk 的大小会有很大一部分重合啊，那 small bin 中对应大小的 bin 是不是就没有什么作用啊？</strong> 其实不然，fast bin 中的 chunk 是有可能被放到small
bin中去的。</p>
</div>
<div class="section" id="large-bin">
<h4>large bin<a class="headerlink" href="#large-bin" title="Permalink to this headline">¶</a></h4>
<p>large bins 中一共包括 63 个 bin，每个bin中的chunk的大小不再一致，而是处于一定区间范围内。此外，这63个bin被分成了6组，每组bin中的chunk大小之间的公差一致，具体如下：</p>
<table border="1" class="docutils">
<colgroup>
<col width="24%" />
<col width="32%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">组</th>
<th class="head">数量</th>
<th class="head">公差</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>1</td>
<td>32</td>
<td>64B</td>
</tr>
<tr class="row-odd"><td>2</td>
<td>16</td>
<td>512B</td>
</tr>
<tr class="row-even"><td>3</td>
<td>8</td>
<td>4096B</td>
</tr>
<tr class="row-odd"><td>4</td>
<td>4</td>
<td>32768B</td>
</tr>
<tr class="row-even"><td>5</td>
<td>2</td>
<td>262144B</td>
</tr>
<tr class="row-odd"><td>6</td>
<td>1</td>
<td>不限制</td>
</tr>
</tbody>
</table>
<p>这里我们以32位平台的large bin为例，第一个large bin的起始chunk大小为512字节，其位于第一组，所以该bin可以存储的chunk的大小范围为[512,512+64)。</p>
<p>关于large bin的宏如下，这里我们以32位平台下，第一个large bin的起始chunk大小为例，为512字节，那么</p>
<p>512&gt;&gt;6 = 8，所以其下标为56+8=64。</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>##define largebin_index_32(sz)                                                  \
    (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 38)                                     \
         ? 56 + (((unsigned long) (sz)) &gt;&gt; 6)                                  \
         : ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20)                               \
               ? 91 + (((unsigned long) (sz)) &gt;&gt; 9)                            \
               : ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10)                        \
                     ? 110 + (((unsigned long) (sz)) &gt;&gt; 12)                    \
                     : ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4)                   \
                           ? 119 + (((unsigned long) (sz)) &gt;&gt; 15)              \
                           : ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2)             \
                                 ? 124 + (((unsigned long) (sz)) &gt;&gt; 18)        \
                                 : 126)

##define largebin_index_32_big(sz)                                              \
    (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 45)                                     \
         ? 49 + (((unsigned long) (sz)) &gt;&gt; 6)                                  \
         : ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20)                               \
               ? 91 + (((unsigned long) (sz)) &gt;&gt; 9)                            \
               : ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10)                        \
                     ? 110 + (((unsigned long) (sz)) &gt;&gt; 12)                    \
                     : ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4)                   \
                           ? 119 + (((unsigned long) (sz)) &gt;&gt; 15)              \
                           : ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2)             \
                                 ? 124 + (((unsigned long) (sz)) &gt;&gt; 18)        \
                                 : 126)

// XXX It remains to be seen whether it is good to keep the widths of
// XXX the buckets the same or whether it should be scaled by a factor
// XXX of two as well.
##define largebin_index_64(sz)                                                  \
    (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 48)                                     \
         ? 48 + (((unsigned long) (sz)) &gt;&gt; 6)                                  \
         : ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20)                               \
               ? 91 + (((unsigned long) (sz)) &gt;&gt; 9)                            \
               : ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10)                        \
                     ? 110 + (((unsigned long) (sz)) &gt;&gt; 12)                    \
                     : ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4)                   \
                           ? 119 + (((unsigned long) (sz)) &gt;&gt; 15)              \
                           : ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2)             \
                                 ? 124 + (((unsigned long) (sz)) &gt;&gt; 18)        \
                                 : 126)

##define largebin_index(sz)                                                     \
    (SIZE_SZ == 8 ? largebin_index_64(sz) : MALLOC_ALIGNMENT == 16             \
                                                ? largebin_index_32_big(sz)    \
                                                : largebin_index_32(sz))
</pre></div>
</div>
</div>
<div class="section" id="unsorted-bin">
<h4>unsorted bin<a class="headerlink" href="#unsorted-bin" title="Permalink to this headline">¶</a></h4>
<p>unsorted bin可以视为空闲 chunk 回归其所属 bin 之前的缓冲区。</p>
<p>其在glibc中具体的说明如下</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span>
   <span class="n">Unsorted</span> <span class="n">chunks</span>

    <span class="n">All</span> <span class="n">remainders</span> <span class="kn">from</span> <span class="nn">chunk</span> <span class="n">splits</span><span class="p">,</span> <span class="k">as</span> <span class="n">well</span> <span class="k">as</span> <span class="nb">all</span> <span class="n">returned</span> <span class="n">chunks</span><span class="p">,</span>
    <span class="n">are</span> <span class="n">first</span> <span class="n">placed</span> <span class="ow">in</span> <span class="n">the</span> <span class="s2">&quot;unsorted&quot;</span> <span class="nb">bin</span><span class="o">.</span> <span class="n">They</span> <span class="n">are</span> <span class="n">then</span> <span class="n">placed</span>
    <span class="ow">in</span> <span class="n">regular</span> <span class="n">bins</span> <span class="n">after</span> <span class="n">malloc</span> <span class="n">gives</span> <span class="n">them</span> <span class="n">ONE</span> <span class="n">chance</span> <span class="n">to</span> <span class="n">be</span> <span class="n">used</span> <span class="n">before</span>
    <span class="n">binning</span><span class="o">.</span> <span class="n">So</span><span class="p">,</span> <span class="n">basically</span><span class="p">,</span> <span class="n">the</span> <span class="n">unsorted_chunks</span> <span class="nb">list</span> <span class="n">acts</span> <span class="k">as</span> <span class="n">a</span> <span class="n">queue</span><span class="p">,</span>
    <span class="k">with</span> <span class="n">chunks</span> <span class="n">being</span> <span class="n">placed</span> <span class="n">on</span> <span class="n">it</span> <span class="ow">in</span> <span class="n">free</span> <span class="p">(</span><span class="ow">and</span> <span class="n">malloc_consolidate</span><span class="p">),</span>
    <span class="ow">and</span> <span class="n">taken</span> <span class="n">off</span> <span class="p">(</span><span class="n">to</span> <span class="n">be</span> <span class="n">either</span> <span class="n">used</span> <span class="ow">or</span> <span class="n">placed</span> <span class="ow">in</span> <span class="n">bins</span><span class="p">)</span> <span class="ow">in</span> <span class="n">malloc</span><span class="o">.</span>

    <span class="n">The</span> <span class="n">NON_MAIN_ARENA</span> <span class="n">flag</span> <span class="ow">is</span> <span class="n">never</span> <span class="nb">set</span> <span class="k">for</span> <span class="n">unsorted</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">so</span> <span class="n">it</span>
    <span class="n">does</span> <span class="ow">not</span> <span class="n">have</span> <span class="n">to</span> <span class="n">be</span> <span class="n">taken</span> <span class="n">into</span> <span class="n">account</span> <span class="ow">in</span> <span class="n">size</span> <span class="n">comparisons</span><span class="o">.</span>
 <span class="o">*/</span>
</pre></div>
</div>
<p>从下面的宏我们可以看出</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span> <span class="n">The</span> <span class="n">otherwise</span> <span class="n">unindexable</span> <span class="mi">1</span><span class="o">-</span><span class="nb">bin</span> <span class="ow">is</span> <span class="n">used</span> <span class="n">to</span> <span class="n">hold</span> <span class="n">unsorted</span> <span class="n">chunks</span><span class="o">.</span> <span class="o">*/</span>
<span class="c1">##define unsorted_chunks(M) (bin_at(M, 1))</span>
</pre></div>
</div>
<p>unsorted bin 处于我们之前所说的数组下标1处。故而，unsorted bin只有一个链表，其中的空闲chunk处于乱序状态，主要有两个来源</p>
<ul class="simple">
<li>当一个较大的 chunk 被分割成两半后，如果剩下的部分大于MINSIZE，就会被放到unsorted bin中。</li>
<li>释放一个不属于 fast bin 的chunk，并且该 chunk 不和 top chunk紧邻时，该chunk会被首先放到 unsorted bin中。关于top chunk的解释，请参考下面的介绍。</li>
</ul>
<p>此外，Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO 。</p>
</div>
<div class="section" id="common-macro">
<h4>common macro<a class="headerlink" href="#common-macro" title="Permalink to this headline">¶</a></h4>
<p>这里介绍一些通用的宏。</p>
<p><strong>根据chunk的大小统一地获得chunk所在的索引</strong></p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span>##define bin_index(sz)                                                          \
    ((in_smallbin_range(sz)) ? smallbin_index(sz) : largebin_index(sz))
</pre></div>
</div>
</div>
</div>
<div class="section" id="top-chunk">
<h3>top chunk<a class="headerlink" href="#top-chunk" title="Permalink to this headline">¶</a></h3>
<p>glibc中对于top chunk的描述如下</p>
<div class="code cpp highlight-default"><div class="highlight"><pre><span></span><span class="o">/*</span>
   <span class="n">Top</span>

    <span class="n">The</span> <span class="n">top</span><span class="o">-</span><span class="n">most</span> <span class="n">available</span> <span class="n">chunk</span> <span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="p">,</span> <span class="n">the</span> <span class="n">one</span> <span class="n">bordering</span> <span class="n">the</span> <span class="n">end</span> <span class="n">of</span>
    <span class="n">available</span> <span class="n">memory</span><span class="p">)</span> <span class="ow">is</span> <span class="n">treated</span> <span class="n">specially</span><span class="o">.</span> <span class="n">It</span> <span class="ow">is</span> <span class="n">never</span> <span class="n">included</span> <span class="ow">in</span>
    <span class="nb">any</span> <span class="nb">bin</span><span class="p">,</span> <span class="ow">is</span> <span class="n">used</span> <span class="n">only</span> <span class="k">if</span> <span class="n">no</span> <span class="n">other</span> <span class="n">chunk</span> <span class="ow">is</span> <span class="n">available</span><span class="p">,</span> <span class="ow">and</span> <span class="ow">is</span>
    <span class="n">released</span> <span class="n">back</span> <span class="n">to</span> <span class="n">the</span> <span class="n">system</span> <span class="k">if</span> <span class="n">it</span> <span class="ow">is</span> <span class="n">very</span> <span class="n">large</span> <span class="p">(</span><span class="n">see</span>
    <span class="n">M_TRIM_THRESHOLD</span><span class="p">)</span><span class="o">.</span>  <span class="n">Because</span> <span class="n">top</span> <span class="n">initially</span>
    <span class="n">points</span> <span class="n">to</span> <span class="n">its</span> <span class="n">own</span> <span class="nb">bin</span> <span class="k">with</span> <span class="n">initial</span> <span class="n">zero</span> <span class="n">size</span><span class="p">,</span> <span class="n">thus</span> <span class="n">forcing</span>
    <span class="n">extension</span> <span class="n">on</span> <span class="n">the</span> <span class="n">first</span> <span class="n">malloc</span> <span class="n">request</span><span class="p">,</span> <span class="n">we</span> <span class="n">avoid</span> <span class="n">having</span> <span class="nb">any</span> <span class="n">special</span>
    <span class="n">code</span> <span class="ow">in</span> <span class="n">malloc</span> <span class="n">to</span> <span class="n">check</span> <span class="n">whether</span> <span class="n">it</span> <span class="n">even</span> <span class="n">exists</span> <span class="n">yet</span><span class="o">.</span> <span class="n">But</span> <span class="n">we</span> <span class="n">still</span>
    <span class="n">need</span> <span class="n">to</span> <span class="n">do</span> <span class="n">so</span> <span class="n">when</span> <span class="n">getting</span> <span class="n">memory</span> <span class="kn">from</span> <span class="nn">system</span><span class="p">,</span> <span class="n">so</span> <span class="n">we</span> <span class="n">make</span>
    <span class="n">initial_top</span> <span class="n">treat</span> <span class="n">the</span> <span class="nb">bin</span> <span class="k">as</span> <span class="n">a</span> <span class="n">legal</span> <span class="n">but</span> <span class="n">unusable</span> <span class="n">chunk</span> <span class="n">during</span> <span class="n">the</span>
    <span class="n">interval</span> <span class="n">between</span> <span class="n">initialization</span> <span class="ow">and</span> <span class="n">the</span> <span class="n">first</span> <span class="n">call</span> <span class="n">to</span>
    <span class="n">sysmalloc</span><span class="o">.</span> <span class="p">(</span><span class="n">This</span> <span class="ow">is</span> <span class="n">somewhat</span> <span class="n">delicate</span><span class="p">,</span> <span class="n">since</span> <span class="n">it</span> <span class="n">relies</span> <span class="n">on</span>
    <span class="n">the</span> <span class="mi">2</span> <span class="n">preceding</span> <span class="n">words</span> <span class="n">to</span> <span class="n">be</span> <span class="n">zero</span> <span class="n">during</span> <span class="n">this</span> <span class="n">interval</span> <span class="k">as</span> <span class="n">well</span><span class="o">.</span><span class="p">)</span>
 <span class="o">*/</span>

<span class="o">/*</span> <span class="n">Conveniently</span><span class="p">,</span> <span class="n">the</span> <span class="n">unsorted</span> <span class="nb">bin</span> <span class="n">can</span> <span class="n">be</span> <span class="n">used</span> <span class="k">as</span> <span class="n">dummy</span> <span class="n">top</span> <span class="n">on</span> <span class="n">first</span> <span class="n">call</span> <span class="o">*/</span>
<span class="c1">##define initial_top(M) (unsorted_chunks(M))</span>
</pre></div>
</div>
<p>程序第一次进行 malloc 的时候，heap 会被分为两块，一块给用户，剩下的那块就是 top chunk。其实，所谓的top chunk 就是处于当前堆的物理地址最高的 chunk。这个 chunk 不属于任何一个
bin，它的作用在于当所有的bin 都无法满足用户请求的大小时，如果其大小不小于指定的大小，就进行分配，并将剩下的部分作为新的top chunk。否则，就对heap进行扩展后再进行分配。在main
arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap。</p>
<p>需要注意的是，top chunk 的 prev_inuse 比特位始终为1，否则其前面的chunk就会被合并到top chunk中。</p>
</div>
<div class="section" id="last-remainder">
<h3>last remainder<a class="headerlink" href="#last-remainder" title="Permalink to this headline">¶</a></h3>
<p>在用户使用 malloc 请求分配内存时，ptmalloc2 找到的 chunk 可能并不是和申请的大小一致，这时候就将分割之后的剩余部分称之为 last remainder chunk ，unsort bin也会存这一块。</p>
</div>
</div>
</div>


    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
    </p>
    <p>
        &copy; Copyright 2016-2017, CTF Wiki.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.5.<br/>
    </p>
  </div>
</footer>
  </body>
</html>