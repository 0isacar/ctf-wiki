..

off-by-one漏洞原理
==================

介绍
----

严格来说off-by-one漏洞是一种特殊的溢出漏洞，off-by-one是指程序向缓冲区中进行写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且这个越界只越了一个字节。

off-by-one漏洞原理
------------------

off-by-one是指1字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关，当然也不排除写入的size正好就只多了一个字节的情况。
其中边界验证不严是指使用比如循环向堆块中写入数据时，循环的次数设置错误(这在C语言初学者中很常见)导致多写入了一个字节。
一般来说，1字节溢出通常被认为是难以利用的，但是因为Linux的堆管理机制ptmalloc验证的松散性，基于Linux堆的off-by-one漏洞利用起来并不复杂，并且威力强大。
此外还要说明的一点是off-by-one是可以基于各种缓冲区的，比如栈、bss段等等，但是堆上(heap
based)的off-by-one是能够利用的也是CTF中最主要出现的，因此我们这里仅讨论堆上的off-by-one情况。

基本示例
--------

下面的示例演示了这一点。

::

    int my_gets(char *ptr,int size)
    {
        int i;
        for(i=0;i<=size;i++)
        {
            ptr[i]=getchar();
        }
        return i;
    }
    int main()
    {
        void *chunk1,*chunk2;
        chunk1=malloc(16);
        chunk2=malloc(16);
        puts("Get Input:");
        my_gets(chunk1,16);
        return 0;
    }

我们自己编写的my_gets函数导致了一个off-by-one漏洞，原因是for循环的边界没有控制好导致写入多执行了一次，这也被称为栅栏错误

    wikipedia:
    栅栏错误（有时也称为电线杆错误或者灯柱错误）是差一错误的一种。如以下问题：

::

        建造一条直栅栏（即不围圈），长30米、每条栅栏柱间相隔3米，需要多少条栅栏柱？

最容易想到的答案10是错的。这个栅栏有10个间隔，11条栅栏柱。

我们使用gdb对程序进行调试，在进行输入前可以看到分配的两个用户区域为16字节的堆块

::

    0x602000:   0x0000000000000000  0x0000000000000021 <=== chunk1
    0x602010:   0x0000000000000000  0x0000000000000000
    0x602020:   0x0000000000000000  0x0000000000000021 <=== chunk2
    0x602030:   0x0000000000000000  0x0000000000000000

当我们执行my_gets进行输入之后，可以看到数据发生了溢出覆盖到了下一个堆块的pre_inuse域

::

    0x602000:   0x0000000000000000  0x0000000000000021 <=== chunk1
    0x602010:   0x4141414141414141  0x4141414141414141
    0x602020:   0x0000000000000041  0x0000000000000021 <=== chunk2 
    0x602030:   0x0000000000000000  0x0000000000000000

第二种常见的导致off-by-one的场景就是字符串操作了，常见的原因是字符串的结束符计算有误

::

    int main(void)
    {
        char buffer[40]="";
        void *chunk1;
        chunk1=malloc(24);
        puts("Get Input");
        gets(buffer);
        if(strlen(buffer)==24)
        {
            strcpy(chunk1,buffer);
        }
        return 0;
        
    }

程序乍看上去没有任何问题(不考虑栈溢出)，可能很多人在实际的代码中也是这样写的。
但是strlen和strcpy的行为不一致却导致了off-by-one的发生。
strlen是我们很熟悉的计算ascii字符串长度的函数，这个函数在计算字符串长度时是不把结束符 '\x00' 计算在内的，但是strcpy在复制字符串时会拷贝结束符 '\x00' 。这就导致了我们向chunk1中写入了25个字节，我们使用gdb进行调试可以看到这一点。

::

    0x602000:   0x0000000000000000  0x0000000000000021 <=== chunk1
    0x602010:   0x0000000000000000  0x0000000000000000
    0x602020:   0x0000000000000000  0x0000000000000411 <=== next chunk

当我们执行了strcpy之后

::

    0x602000:   0x0000000000000000  0x0000000000000021
    0x602010:   0x4141414141414141  0x4141414141414141
    0x602020:   0x4141414141414141  0x0000000000000400

可以看到next chunk的chunk_header.size域低字节被结束符 '\x00' 覆盖，这种又属于off-by-one的一个分支称为NULL
byte off-by-one，我们在后面会看到off-by-one与NULL byte
off-by-one在利用上的区别。
还是有一点就是为什么是低字节被覆盖呢，因为我们通常使用的CPU的字节序都是小端法的，比如一个DWORD值在使用小端法的内存中是这样储存的

::

    DWORD 0x41424344
    内存  0x44,0x43,0x42,0x41

小总结
------

上面的示例其实也展示了寻找off-by-one中比较重要的几个步骤:

注意循环边界
------------

在进行诸如循环写入的操作时，要特别注意循环的次数是否存在边界问题导致的off-by-one。

注意字符串操作
--------------

字符串结束符处理的不严谨往往会导致off-by-one问题的发生。
